{"title": "How does C compiler handle post-increment (i++), memory wise?", "tags": ["c", "gcc", "increment", "c99"], "creation_date": 1476902686, "score": 2, "body": "<p>Your assumption that compilers always produce different results for <code>++i</code> and <code>i++</code> <strong>without optmization</strong> is false. Here's a look at pre and post increment <a href=\"https://godbolt.org/g/yKDrk1\" rel=\"nofollow\">on godbolt</a>, in gcc 6.2, no optimization:</p>\n\n<h3>The C Code</h3>\n\n<pre><code>int pre() {\n  int i = 0;\n  ++i;\n}\n\nint post() {\n  int i= 0;\n  i++;\n}\n</code></pre>\n\n<h3>The Assembly (x86-64)</h3>\n\n<pre><code>pre():\n        push    rbp\n        mov     rbp, rsp\n        mov     DWORD PTR [rbp-4], 0\n        add     DWORD PTR [rbp-4], 1\n        nop\n        pop     rbp\n        ret\n\npost():\n        push    rbp\n        mov     rbp, rsp\n        mov     DWORD PTR [rbp-4], 0\n        add     DWORD PTR [rbp-4], 1\n        nop\n        pop     rbp\n        ret\n</code></pre>\n\n<p>Note that the compiled code is byte-for-byte identical here for <code>i++</code> and <code>++i</code>. Both simply add 1 to the memory location reserved on the stack for <code>i</code>. No temporary is created or needed.</p>\n\n<p>You might complain that I'm not actually using the value of the incremented expression, so let's <a href=\"https://godbolt.org/g/YL0dpQ\" rel=\"nofollow\">look at something</a> that actually does use the value:</p>\n\n<h3>The C Code</h3>\n\n<pre><code>int pre(int i) {\n  return ++i;\n}\n\nint post(int i) {\n  return i++;\n}\n</code></pre>\n\n<h3>The Assembly (x86-64)</h3>\n\n<pre><code>pre(int):\n        push    rbp\n        mov     rbp, rsp\n        mov     DWORD PTR [rbp-4], edi\n        add     DWORD PTR [rbp-4], 1\n        mov     eax, DWORD PTR [rbp-4]\n        pop     rbp\n        ret\n\npost(int):\n        push    rbp\n        mov     rbp, rsp\n        mov     DWORD PTR [rbp-4], edi\n        mov     eax, DWORD PTR [rbp-4]\n        lea     edx, [rax+1]\n        mov     DWORD PTR [rbp-4], edx\n        pop     rbp\n        ret\n</code></pre>\n\n<p>Here, the assembly is different. The pre-increment version uses a memory RMW (read-modify-write) instruction to increment the variable, while the post-increment version increments the variable separately through <code>edx</code>. While looking at un-optimized code is always an exercise in futility, I'm quite sure the post-increment version is <em>faster</em> here, as the dependency chain is smaller due to no RMW instruction in the critical path and subsequent store forwarding stall.</p>\n\n<p>A key note is that even here there is no \"temporary space\" allocated in memory - only the assembly changes, and a register (<code>eax</code> here) is used for free as the resting place for the value of <code>i</code> before the post-increment.</p>\n\n<p>Of course, you shouldn't really read <em>anything</em> into unoptimized code. It isn't going to be used in practice and you can't really learn much about the efficiency of any construct by studying it, because the optimized code will vary wildly across different idioms.</p>\n\n<p>So finally, let's look at <a href=\"https://godbolt.org/g/K9i7QX\" rel=\"nofollow\">a realistic example</a> where we are using optimization, and <em>both</em> the value of the increment expression and the underlying variable is actually used (so neither value is optimized away). Here we take an <code>int &amp;</code> reference to i in each function so that the passed-in value is modified. We use -O2, although every other optimization level I tried produces identical results, other than <code>-Os</code>:</p>\n\n<h3>The C Code</h3>\n\n<pre><code>int pre(int&amp; i) {\n  return ++i;\n}\n\nint post(int&amp; i) {\n  return i++;\n}\n</code></pre>\n\n<h3>The Assembly (x86-64)</h3>\n\n<pre><code>pre(int&amp;):\n        mov     eax, DWORD PTR [rdi]\n        add     eax, 1\n        mov     DWORD PTR [rdi], eax\n        ret\n\npost(int&amp;):\n        mov     eax, DWORD PTR [rdi]\n        lea     edx, [rax+1]\n        mov     DWORD PTR [rdi], edx\n        ret \n</code></pre>\n\n<p>Both functions are almost exactly the same cost. They have the same number of instructions, and on modern Intel hardware produce the same number of uops (4 fused-domain) with the same cost. The functions take exactly the same number of instruction bytes<sup>1</sup>.</p>\n\n<p>The post-increment differs in that it uses a <code>lea</code> instruction to put its result in <code>edx</code>, so that <code>eax</code> remains un-incremented as the return value. The pre-increment version simply uses <code>eax</code> for everything. The use of <code>edx</code> has no direct cost here because it is a scratch register in x86-64, so there is no need to save its value. In a more complex code, the use of another register <em>could</em> increase register pressure, although it is fairly unlikely because the lifetime is very small and there are more opportunities for re-ordering.</p>\n\n<p>The post-increment version actually has a smaller dependency chain for the return value - assuming the caller uses the return value in <code>eax</code>, it will take 1 additional cycle for it to be ready (since the <code>add eax, 1</code> is part of the dependency chain). That's actually inherent in the pre-increment definition: <em>in one way, pre-increment is slower</em>, because the increment and subsequent use of the value must occur serially, while in the post-increment case they can occur in parallel, since the use of the value doesn't depend on the increment operation. Of course, this effect is very small - not usually more than a single cycle. The classic advice to use pre-increment probably still applies because for objects it can make a <em>big</em> difference. For primitives, not so much.</p>\n\n<hr>\n\n<p><sup>1</sup>Interestingly, the pre-increment version could have been implemented with <code>inc eax</code> rather than <code>add eax, 1</code>, which is probably as fast on modern hardware and saves a byte. It probably isn't because of the mostly obsolete advice to avoid <code>inc</code> and <code>dec</code> due to partial flag stalls. In fact, with <code>-Os</code> (optimize for size) gcc <em>does</em> use an <code>inc</code> here.</p>\n", "last_activity_date": 1476904667, "answer_id": 40139255, "is_accepted": true, "owner": {"user_id": 149138, "reputation": 6036, "user_type": "registered", "accept_rate": 67, "display_name": "BeeOnRope", "link": "http://stackoverflow.com/users/149138/beeonrope", "profile_image": "https://www.gravatar.com/avatar/cfd457233c8ebbab383475fc097442d9?s=128&d=identicon&r=PG"}, "last_edit_date": 1476904667, "question_id": 40139036}