{"title": "Delete an element from a linked list with constraints", "tags": ["java", "linked-list"], "creation_date": 1476926232, "score": 0, "body": "<p>The reason the code copies the data rather than modifying the variable referencing the head is that other users of the list will have a reference to the head node. Changing the local variable will have no effect on their references so you won't have actually deleted the node. Copying the data to the head node effectively removes it.</p>\n\n<p>So, for example, if you had code that did the following:</p>\n\n<pre><code>Node head = new Node(\"A\");\nNode tail = new Node(\"B\");\nhead.next = tail;\ndeleteNode(head, head);\n</code></pre>\n\n<p>Then you would expect <code>head.data</code> to be \"B\" because the original node has been deleted. If you merely do <code>node = node.next</code> then <code>head</code> will still point to the original deleted node.</p>\n\n<p>There are quite a few issues with the code you've posted so please add a comment if you want suggestions on improvements that should be made. It is not a typical algorithm for deleting nodes from a linked list.</p>\n\n<p>One clear issue you've asked about is the use of <code>System.gc</code>. It is not necessary. There are rare cases when Java code needs to take explicit control of garbage collection. This isn't one of them. There's a good explanation of this in the accepted answer to <a href=\"http://stackoverflow.com/questions/2414105/why-is-it-bad-practice-to-call-system-gc\">this question</a>. </p>\n\n<p>You asked in the comments why deleting the head requires moving data while deleting other nodes only requires redirection around the node. The reason is because you don't have access to references to the head (as explained in the answer above). You do have access to references to other nodes (i.e. the previous node's <code>next</code>) so they can be changed directly rather than having to copy data.</p>\n\n<p>For your reference, a much more standard implementation is to have the list itself store a reference to the head. Then the copying of node data can be completely avoided. Also note this compares to a value because the node class is private.</p>\n\n<pre><code>static class LinkedList&lt;T&gt; {\n    private class Node {\n        private final T value;\n        private Node next = null;\n\n        public Node(T value) {\n            this.value = value;\n        }\n    }\n\n    private Node head = null;\n\n    public void add(T value) {\n        Node node = new Node(value);\n        node.next = head;\n        head = node;\n    }\n\n    public void remove(T value) {\n        while (head != null &amp;&amp; head.value.equals(value))\n            head = head.next;\n        Node prev = head;\n        while (prev != null &amp;&amp; prev.next != null) {\n            if (prev.next.value.equals(value))\n                prev.next = prev.next.next;\n            else\n                prev = prev.next;\n        }\n    }\n}\n</code></pre>\n\n<p>This avoids the arbitrary restrictions in the example you provided such as not being able to delete the head if it's the only node.</p>\n", "last_activity_date": 1476958655, "answer_id": 40143961, "is_accepted": true, "owner": {"user_id": 3705127, "reputation": 10046, "user_type": "registered", "accept_rate": 53, "display_name": "sprinter", "link": "http://stackoverflow.com/users/3705127/sprinter", "profile_image": "https://www.gravatar.com/avatar/b03aedaddfa4dc1c2b331f318a724ec7?s=128&d=identicon&r=PG&f=1"}, "last_edit_date": 1476958655, "question_id": 40143886}