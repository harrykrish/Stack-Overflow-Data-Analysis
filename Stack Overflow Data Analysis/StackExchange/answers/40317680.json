{"title": "How can a C pointer of type int hold a memory address, given that a byte memory address is not of type int?", "tags": ["c", "pointers"], "creation_date": 1477732944, "score": 0, "body": "<p>I think the reason <code>int *p2 = &amp;i;</code> is confusing is the combined effect of the simultaneous declaration and instantiation, and the spacing.  I'll explain.</p>\n\n<p>Typically, for a pointer-to-integer <code>p2</code> and an integer <code>i</code>, writing \"<code>*p2</code>\" dereferences <code>p2</code> and gives the <code>int</code> living at the address <code>&amp;i</code>.</p>\n\n<p>So the code \"<code>int *p2 = &amp;i;</code>\" makes it look like an <code>int</code> is being set equal to a memory address.</p>\n\n<p>Indeed, the code </p>\n\n<pre><code>int i = 1;\nint *p2;\n*p2 = &amp;i\n</code></pre>\n\n<p>is wrong, because in the last line, <code>*p2</code> is an <code>int</code> since it is <code>p2</code> dereferenced, and <code>&amp;i</code> is a pointer.</p>\n\n<p><strong>Why</strong> <code>int *p2 = &amp;i;</code> <strong>is NOT doing the same thing as the last line of the flawed code above:</strong></p>\n\n<p>The code <code>int *p2 = &amp;i;</code> is different from the 3 lines of code above because it is a declaration.  When you declare a pointer variable, you put the type, (e.g. <code>int</code>, <code>long</code>, <code>char</code>, etc.), and the name of your variable (like normal) - and you also put an asterisk <code>*</code> in between these two pieces (see @chqrlie answer above with regard to the many spacing options for this - takehome is best-practice is to adhere the <code>*</code> to the variable name).  In a declaration, the <code>*</code> is NOT dereferencing the pointer.  Rather, it is telling the compiler that the variable <code>myPointer</code> will be a pointer to memory holding data of the declared type (the <code>int</code>, <code>long</code>, <code>char</code>, etc. from before).  So, in the bit of code \"<code>int *p2 = &amp;i;</code>\", where the pointer is being declared and instantiated at the same time, the <code>*</code> does not render an <code>int</code> on the left-hand side.  For declarations, while it is safer (as @chqrlie points out) to put the <code>*</code> next to the variable name, this does not unwrap the pointer even if the pointer is instantiated in the declaration.  For declarations, think of the <code>*</code> as being attached to the type (rather than to the variable name, where for good reasons it is likely to be).  I like to declare pointers with the <code>*</code> right next to the pointer name, but just understand that when instantiating a pointer in the declaration, a perhaps clearer way for a new learner to imagine the line would be <code>int* p2 = &amp;1</code>: </p>\n\n<p><code>int*</code> (type pionter-to-int) <code>p2</code> (name of pointer) <code>= &amp;i</code> (equals the pointer that gives the address of integer <code>i</code>) <code>;</code> </p>\n\n<p>Thank you to everyone who answered and commented, and good luck to everyone who may have come here trying to figure out something about pointers. </p>\n", "last_activity_date": 1477733853, "answer_id": 40317680, "is_accepted": false, "owner": {"user_id": 6542449, "reputation": 6, "user_type": "registered", "display_name": "hlp", "link": "http://stackoverflow.com/users/6542449/hlp", "profile_image": "https://www.gravatar.com/avatar/6e2952caccf045a96bf4aa5fc6d0d99f?s=128&d=identicon&r=PG&f=1"}, "last_edit_date": 1477733853, "question_id": 38557911}