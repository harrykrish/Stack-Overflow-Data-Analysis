{"body": "<p>I want to start by saying that <code>Input</code> and <code>Touches</code> are not crappy.They are still usefull and were the best way to check for <code>touch</code> on mobile devices before <code>OnPointerDown</code> and <code>OnBeginDrag</code> came along. <code>OnMouseDown()</code> you can call crappy because it was not optimized for mobile. For a <strong>beginner</strong> who just <strong>started</strong> to learn Unity, <code>Input</code> and <code>Touches</code> are their options.</p>\n\n<p>As for your question, <code>OnPointerDown</code> and <code>OnBeginDrag</code> are <strong>NOT</strong> the-same. Although they  almost do the-same thing but they were implemented to perform in different ways. Below I will describe most of these:</p>\n\n<p><code>OnPointerDown</code>:\nCalled when there is press/touch on the screen (when there is a click or finger is pressed down on touch screen)</p>\n\n<p><code>OnPointerUp</code>:\nCalled when press/touch is released (when click is released or finger is removed from the touch screen)</p>\n\n<p><code>OnBeginDrag</code>:\nCalled <strong>once</strong> before a drag is started(when the finger/mouse is moved for the <strong>first</strong> time while down)</p>\n\n<p><code>OnDrag</code> :\nRepeatedly called when user is dragging on the screen (when the finger/mouse is moving on the touch screen)</p>\n\n<p><code>OnEndDrag</code>:\nCalled when drag stops (when the finger/mouse is no <strong>longer</strong> moving on the touch screen). </p>\n\n<p><strong><code>OnPointerDown</code></strong> versus <strong><code>OnBeginDrag</code></strong> and <strong><code>OnEndDrag</code></strong></p>\n\n<p><code>OnPointerUp</code> will <strong>NOT</strong> be called if <code>OnPointerDown</code> <strong>has not been</strong> called. <code>OnEndDrag</code> will <strong>NOT</strong> be called if <code>OnBeginDrag</code> <strong>has not been</strong> called. Its like the curly braces in C++,C#, you <strong>open</strong> it '<strong>{</strong>' and you <strong>close</strong> it '<strong>}</strong>'. </p>\n\n<p><strong>THE DIFFERENCE</strong>:\nOnPointerDown will be called <strong>once</strong> and <strong>immediately</strong> when finger/mouse is on the touch screen. Nothing else will happen until there is a mouse movement or the finger moves on the screen then <code>OnBeginDrag</code> will be called <strong>once</strong> followed by OnDrag.</p>\n\n<p><em>These are made for doing advanced usage such such as <strong>custom</strong> UI with controls that is not included in Unity.</em></p>\n\n<p><strong>WHEN TO USE EACH ONE:</strong></p>\n\n<p><strong>1.</strong> When you have to implement a <strong>simple click button</strong>, for example, Up,Down, Shoot Button on the screen, you <strong>only</strong> need <code>OnPointerDown</code> to detect the touch. This should work for Sprite Images.</p>\n\n<p><strong>2.</strong> When you have to implement a custom <strong>toggle switch</strong> and you want it to be <strong>realistic</strong> so that the player can drag to left/right or up/down to <strong>toggle</strong> it then you need <code>OnPointerDown</code> ,  <code>OnBeginDrag</code> , <code>OnDrag</code> , <code>OnEndDrag</code> , <code>OnPointerUp</code>. You need to write your code in this order to have a <strong>smooth</strong> Sprite/Texture transition on the screen. Some toggle switches are made to be to <strong>clicked</strong> and it will <strong>toggle</strong>. Some people prefer to make it look realistic by making it so that you have to <strong>drag</strong> it in order to <strong>toggle</strong> it.</p>\n\n<p><strong>3.</strong> Also when you want to <strong>implement</strong> a Generic re-usable <strong>pop-up window</strong> that is draggable, you also need to use those 5 functions (<code>OnPointerDown</code> ,  <code>OnBeginDrag</code> , <code>OnDrag</code> , <code>OnEndDrag</code> , <code>OnPointerUp</code>). \nFirst detect when there is a click(<code>OnPointerDown</code>), check to make sure that the Sprite clicked is the right one you want to move. Wait for player to move(<code>OnBeginDrag</code>) their finger/mouse. Once they start dragging, maybe you can call a coroutine function with <code>while</code> <strong>loop</strong> that will start moving the Sprite and inside that coroutine, you can <strong>smooth</strong> the movement of the Sprite with <code>Time.deltaTime</code> or any other preferred method.</p>\n\n<p>Since <code>OnBeginDrag</code> is called once, it is a good place to <strong>start</strong> the <strong>coroutine</strong>. \nAs the player continue to drag the Sprite, <code>OnDrag</code> will be called <strong>repeatedly</strong>. Use the <code>OnDrag</code> function to get the current location of the finder and update that to a <code>Vector3</code> that the coroutine that is <strong>already</strong> running will use to <strong>update</strong> the <strong>position</strong> of the Sprite. When the player <strong>stops</strong> moving their finger/mouse on the screen, <code>OnEndDrag</code> is called and you can <code>boolean</code> variable and tell the coroutine to stop <strong>updating</strong> the position of the Sprite. Then, when the player <strong>releases</strong> their finger(<code>OnPointerUp</code>) you can then stop the coroutine with the StopCoroutine function.</p>\n\n<p>Because of <code>OnBeginDrag</code> we we are able to start coroutine once drag started while waiting for drag to end. It <strong>wouldn't</strong> make <strong>sense</strong> to <strong>start</strong> that coroutine in <code>OnPointerDown</code> because that means that each time player <strong>touches</strong> the screen, a coroutine would be <strong>started</strong>.</p>\n\n<p>Without <code>OnBeginDrag</code>, we have to use <code>boolean</code> variable to make the coroutine start only once in the <code>OnDrag</code> function which is called every time or else there would be coroutine running everywhere and unexpected movement of the Sprite will occur.</p>\n\n<p><strong>4.</strong> When you want to determine how long player moved their finger. Example of this is that famous game called <strong>Fruit Ninja</strong>. Lets just say you want to determine far the player swiped on the screen.</p>\n\n<p>First, <strong>wait</strong> until <code>OnPointerDown</code> is  called, <strong>wait</strong> again until <code>OnBeginDrag</code> is called, then you can get the <strong>current</strong> position of the finger inside <code>OnBeginDrag</code> function because <code>OnBeginDrag</code> is called before the finger starts moving. After the finger is released,  <code>OnEndDrag</code> is called. Then you can get the current position of finger again. You can use these <strong>two</strong> <strong>positions</strong> to check how far the finger moved by <strong>subtracting</strong> them. </p>\n\n<p>If you instead decide to use <code>OnPointerDown</code> as the place to get the <strong>first</strong> <strong>position</strong> of the finger, you will get a <strong>wrong</strong> result because if the player <strong>swipes right</strong>, then <strong>waits</strong> and <strong>swipes left</strong> then <strong>waits</strong> again and <strong>swipe up</strong> <strong>without releasing their finger</strong> after <strong>each</strong> swipe, the only <strong>good</strong> result you have is the <strong>first swipe</strong>(<em>right swipe</em>). The <strong>left</strong> and the <strong>up</strong> swipe will have <strong>invalid</strong> values because that first value you got when <code>OnPointerDown</code> was <strong>called</strong> is the value you are <strong>still</strong> using. This is because the player never removed their finger from the screen so <strong>therefore</strong>, <code>OnPointerDown</code> is <strong>never</strong> called <strong>again</strong> and the first old <strong>old value</strong> is still there. </p>\n\n<p>But when you use <code>OnBeginDrag</code> instead of <code>OnPointerDown</code>, this problem will be <strong>gone</strong> because when the finger <strong>stops moving</strong>, <code>OnEndDrag</code> is called and when it starts moving again <code>OnBeginDrag</code>  is called once again causing the first <strong>position</strong> to be <strong>overwritten</strong> with the <strong>new one</strong>.</p>\n", "tags": ["unity3d", "touch", "unity3d-5", "unity3d-ui"], "creation_date": 1458228069, "score": 5, "last_activity_date": 1458228069, "answer_id": 36064820, "is_accepted": true, "owner": {"user_id": 3785314, "reputation": 17126, "user_type": "registered", "accept_rate": 89, "display_name": "Programmer", "link": "http://stackoverflow.com/users/3785314/programmer", "profile_image": "https://i.stack.imgur.com/sh4Al.png?s=128&g=1"}, "title": "Horrors of OnPointerDown versus OnBeginDrag in Unity3D", "question_id": 36048106}