{"title": "How do I initialize a typescript object with a JSON object", "tags": ["json", "typescript"], "creation_date": 1462034184, "score": 12, "body": "<p>It is amusing how there is still no widely adaptable solution to this elementary problem after more than <em>2 years</em>. <strong>I believe an automatable and generalized solution exists, however.</strong></p>\n\n<ul>\n<li>Long story short: <a href=\"https://github.com/JohnWhiteTB/TypedJSON\" rel=\"nofollow\">TypedJSON</a> <em>(proof of concept)</em></li>\n</ul>\n\n<hr>\n\n<p>The root of the complexity of this problem is that we need to deserialize JSON at <em>runtime</em> using type information that only exists at <em>compile time</em>. There is only one approach I can think of when looking for a maintainable solution to that, which is manually specifying types for properties that are subject to deserialization.</p>\n\n<p>Fortunately however, this can be solved in a very elegant and robust way with <a href=\"https://github.com/Microsoft/TypeScript-Handbook/blob/master/pages/Decorators.md\" rel=\"nofollow\">decorators</a> and <a href=\"https://github.com/rbuckton/ReflectDecorators\" rel=\"nofollow\">ReflectDecorators</a>:</p>\n\n<ol>\n<li>Use <a href=\"https://github.com/Microsoft/TypeScript-Handbook/blob/master/pages/Decorators.md#property-decorators\" rel=\"nofollow\">property decorators</a> on properties which are subject to serialization, to record metadata information and store that information somewhere, for example on the class prototype</li>\n<li>Feed this metadata information to a recursive initializer (deserializer)</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<h2>Recording Type-Information</h2>\n\n<p>With a combination of <a href=\"https://github.com/rbuckton/ReflectDecorators\" rel=\"nofollow\">ReflectDecorators</a> and property decorators, type information can be easily recorded about a property. A rudimentary implementation of this approach would be:</p>\n\n<pre><code>function JsonMember(target: any, propertyKey: string) {\n    var metadataFieldKey = \"__propertyTypes__\";\n\n    // Get the already recorded type-information from target, or create\n    // empty object if this is the first property.\n    var propertyTypes = target[metadataFieldKey] || (target[metadataFieldKey] = {});\n\n    // Get the constructor reference of the current property.\n    // This is provided by TypeScript, built-in (make sure to enable emit\n    // decorator metadata).\n    propertyTypes[propertyKey] = Reflect.getMetadata(\"design:type\", target, propertyKey);\n}\n</code></pre>\n\n<p>For any given property, the above snippet will add a reference to the constructor function of the property into <code>__propertyTypes__</code> on the class prototype, for example:</p>\n\n<pre><code>class Language {\n    @JsonMember // String\n    name: string;\n\n    @JsonMember// Number\n    level: number;\n}\n\nclass Person {\n    @JsonMember // String\n    name: string;\n\n    @JsonMember// Language\n    language: Language;\n}\n</code></pre>\n\n<p>With this, we have the required type-information at <em>runtime</em>, which can now be processed.</p>\n\n<p>&nbsp;</p>\n\n<h2>Processing Type-Information</h2>\n\n<p>When a JSON string needs to be converted into an instance of the provided class, after parsing the string into a simple Javascript object, we can iterate over <code>__propertyTypes__</code> (collected above) and instantiate the required properties accordingly. The type of the root object must be specified, so that the deserializer has a starting-point.</p>\n\n<p>Again, a dead simple implementation of this approach would be:</p>\n\n<pre><code>function deserialize&lt;T&gt;(jsonObject: any, Constructor: { new (): T }): T {\n    if (!Constructor || !Constructor.prototype.__propertyTypes__ || !jsonObject || typeof jsonObject !== \"object\") {\n        // No root-type with usable type-information is available.\n        return jsonObject;\n    }\n\n    // Create an instance of root-type.\n    var instance: any = new Constructor();\n\n    // For each property marked with @JsonMember, do...\n    Object.keys(Constructor.prototype.__propertyTypes__).forEach(propertyKey =&gt; {\n        var PropertyType = Constructor.prototype.__propertyTypes__[propertyKey];\n\n        // Deserialize recursively, treat property type as root-type.\n        instance[propertyKey] = deserialize(jsonObject[propertyKey], PropertyType);\n    });\n\n    return instance;\n}\n</code></pre>\n\n<pre class=\"lang-js prettyprint-override\"><code>var json = '{ \"name\": \"John Doe\", \"language\": { \"name\": \"en\", \"level\": 5 } }';\nvar person: Person = deserialize(JSON.parse(json), Person);\n</code></pre>\n\n<p>The above idea has the <em>huge</em> advantage of deserializing by <em>expected</em> types (for complex/object values), instead of what is present in the JSON. If a <code>Person</code> is expected, then it is a <code>Person</code> instance that is created. With some additional security measures in place for primitive types and arrays, this approach can be made secure, that resists <em>any</em> malicious JSON.</p>\n\n<p>&nbsp;</p>\n\n<h2>Edge Cases</h2>\n\n<p>However, if you are now happy that the solution is <em>that</em> simple, I have some bad news: there is a <em>vast</em> number of edge cases that need to be taken care of. Only some of which are:</p>\n\n<ul>\n<li>Arrays and array elements (especially in nested arrays)</li>\n<li>Polymorphism</li>\n<li>Abstract classes and interfaces</li>\n<li>...</li>\n</ul>\n\n<p>If you don't want to fiddle around with all of these (I bet you don't), I'd be glad to recommend a working experimental version of a proof-of-concept utilizing this approach, <a href=\"https://github.com/JohnWhiteTB/TypedJSON\" rel=\"nofollow\">TypedJSON</a> -- which I created to tackle this exact problem, a problem I face myself daily.</p>\n\n<p>Due to how decorators are still being considered experimental, I wouldn't recommend using it for production use, but so far it served me well.</p>\n", "last_activity_date": 1474407699, "answer_id": 36957454, "is_accepted": false, "owner": {"user_id": 2788872, "reputation": 3682, "user_type": "registered", "accept_rate": 86, "display_name": "John White", "link": "http://stackoverflow.com/users/2788872/john-white", "profile_image": "https://www.gravatar.com/avatar/a2616878b8bfb95d8fbb8a63ad18d729?s=128&d=identicon&r=PG&f=1"}, "last_edit_date": 1474407699, "question_id": 22885995}