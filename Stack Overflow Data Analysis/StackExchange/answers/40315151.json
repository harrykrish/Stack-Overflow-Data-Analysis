{"title": "How to use an arbitrary makeFields lens argument with different types in the same function?", "tags": ["haskell", "lens"], "creation_date": 1477704295, "score": 1, "body": "<p>To decide what is to be done, we need to know what the types of your (<code>makeField</code>-generated) fields are:</p>\n\n<pre><code>GHCi&gt; :t x\nx :: (HasX s a, Functor f) =&gt; (a -&gt; f a) -&gt; s -&gt; f s\n</code></pre>\n\n<p>So the abstraction covering all your <code>x</code>-bearing types (the abstraction I was whining about before noticing you were using <code>makeFields</code>) is a multi-parameter type class <code>HasX</code>, and similarly for the other fields. That gives us enough to use <code>x</code> with different types in a single implementation:</p>\n\n<pre><code>-- Additional extension required: FlexibleContexts\n-- Note that GHC is able to infer this type.\nqx :: (HasX t (a -&gt; b), HasX s a) =&gt; t -&gt; s -&gt; b\nqx t s = (t ^. x) (s ^. x)\n</code></pre>\n\n\n\n<pre><code>GHCi&gt; import Data.Maybe\nGHCi&gt; let testA = A \"foo\" \"bar\"\nGHCi&gt; let testB = B (fromMaybe '\u00f8' . listToMaybe) null\nGHCi&gt; qx testB testA\n'f'\n</code></pre>\n\n<p>That, however, is not quite what you asked for. You wanted something like:</p>\n\n<pre><code>q xOrY b a = (b^.xOrY) (a^.xOrY)\n</code></pre>\n\n<p>Achieving that, however, requires abstracting over the <em>classes</em> <code>HasX</code>, <code>HasY</code>, etc. Doing so is, in fact, somewhat feasible thanks to the <code>ConstraintKinds</code> extension, as demonstrated in <a href=\"http://stackoverflow.com/q/34029594/2751851\"><em>Could we abstract over type classes?</em></a> Here it goes:</p>\n\n<pre><code>-- Additional extensions required: ConstraintKinds, ScopedTypeVariables\n-- Additional import required: Data.Proxy\n-- GHC cannot infer this type.\nq :: forall h s t a b. (h t (a -&gt; b), h s a) =&gt; Proxy a -&gt; Proxy h\n  -&gt; (forall u c. h u c =&gt; Getting c u c) -&gt; t -&gt; s -&gt; b\nq _ _ l t s =\n    (t ^. (l :: Getting (a -&gt; b) t (a -&gt; b))) (s ^. (l :: Getting a s a))\n</code></pre>\n\n\n\n<pre><code>GHCi&gt; q (Proxy :: Proxy String) (Proxy :: Proxy HasX) x testB testA\n'f'\n</code></pre>\n\n<p>The first proxy, which determines the intermediate type, is necessary unless you give up this bit of generality and replace <code>a</code> by <code>String</code>. Additionally, you have to specify the field twice, both by passing the getter as an argument and through the second proxy. I am not at all convinced that this second solution is worth the trouble -- the extra boilerplate of having to define <code>qx</code>, <code>qy</code>, etc. looks quite a bit less painful than all the circuitousness involved here. Still, if any of you who are reading this would like to suggest an improvement, I'm all ears.</p>\n", "last_activity_date": 1477706152, "answer_id": 40315151, "is_accepted": true, "owner": {"user_id": 2751851, "reputation": 9947, "user_type": "registered", "display_name": "duplode", "link": "http://stackoverflow.com/users/2751851/duplode", "profile_image": "https://www.gravatar.com/avatar/ad975cead9593fc516fb50c3287fd721?s=128&d=identicon&r=PG&f=1"}, "last_edit_date": 1477706152, "question_id": 40274998}