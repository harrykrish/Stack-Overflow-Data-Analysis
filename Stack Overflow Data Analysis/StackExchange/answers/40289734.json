{"title": "Assigning array of pointers to string", "tags": ["c", "arrays", "pointers", "2d"], "creation_date": 1477585374, "score": 0, "body": "<p>Because you are not copying whole structures of info that the compiler can understand, you need to copy each element of the array individually.  Usually this is done with a for loop checking for NUL or size, but I am cheating and just showing you the syntax that would do the copy you want:</p>\n\n<pre><code>#define MAXLEN 10\n\nint main(void) \n{\n    char string[2][MAXLEN];\n    char string2[2][MAXLEN];\n    char *pointer[2];\n    pointer[0] = &amp;string2[0];\n    pointer[1] = &amp;string2[1];\n\n    // Replace scanf for simplicity\n    string[0][0] = 'a'; string[0][1] = 'b'; string[0][2] = '\\0';\n    string[1][0] = 'c'; string[1][1] = 'b'; string[1][2] = '\\0';\n\n    // For loop or strcpy/strncpy/etc. are better, but showing array method of copying\n    pointer[0][0] = string[1][0];\n    pointer[0][1] = string[1][1];\n    pointer[0][2] = string[1][2];\n\n    printf(\"%s\", string2[0]);\n\n    return 0;\n}\n</code></pre>\n\n<p>For pointers, you could do this:</p>\n\n<pre><code>#define MAXLEN 10\n\nint main(void) {\n  char string[2][MAXLEN];\n  char string2[2][MAXLEN];\n  char *pointer[2];\n  pointer[0] = &amp;string2[0];\n  pointer[1] = &amp;string[1];  // changed this\n\n  string[0][0] = 'a'; string[0][1] = 'b'; string[0][2] = '\\0';\n  string[1][0] = 'c'; string[1][1] = 'd'; string[1][2] = '\\0';\n\n  *pointer[0]++ = *pointer[1]++;\n  *pointer[0]++ = *pointer[1]++;\n  *pointer[0]++ = *pointer[1]++;\n\n  printf(\"%s\", string2[0]);\n\n  return 0;\n}\n</code></pre>\n\n<p>The pointer magic above turns into:</p>\n\n<pre><code>  char temp = *pointer[1];  // Read the char from dest.\n  pointer[1]++;  // Increment the source pointer to the next char.\n  *pointer[0] = temp;  // Store the read char.\n  pointer[0]++;   // Increment the dest pointer to the next location.\n</code></pre>\n\n<p>and I do it 3 times - one for each char of input.  Surrounding that with a while() check against sourcePtr == '\\0' basically turns it into strcpy().</p>\n\n<p>One more fun example where a dereference might do what you expect:</p>\n\n<pre><code>typedef struct foo\n{\n    char mystring[16];\n} FOO;\n\nFOO a,b;\n\n// This does a copy\na = b;\n\n// This also does a copy\nFOO *p1 = &amp;a, *p2=&amp;b;\n*p1 = *p2;\n\n// As does this\n*p1 = a;\n\n// But this does not and will not compile:\na.mystring = b.mystring;\n\n// Because arrays in 'C' are treated different than other types.\n// The above says: Take the address of b.mystring and assign it (illegally because the array's location in memory cannot be changed like this) to a.mystring.\n</code></pre>\n", "last_activity_date": 1477682854, "answer_id": 40289734, "is_accepted": true, "owner": {"user_id": 527574, "reputation": 9202, "user_type": "registered", "accept_rate": 90, "display_name": "Michael Dorgan", "link": "http://stackoverflow.com/users/527574/michael-dorgan", "profile_image": "https://www.gravatar.com/avatar/e5b251b4ac8f0cb7942587ee8077cddb?s=128&d=identicon&r=PG"}, "last_edit_date": 1477682854, "question_id": 40286515}