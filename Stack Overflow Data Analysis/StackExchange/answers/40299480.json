{"title": "Trying to understand complexity of quick sort", "tags": ["java", "arrays", "algorithm", "sorting", "quicksort"], "creation_date": 1477636943, "score": 1, "body": "<p>Little correction to your statement:</p>\n\n<blockquote>\n  <p>I understand worst case happens when the pivot is the smallest or the largest element. </p>\n</blockquote>\n\n<p>Actually, the worst case happens when <em>each successive</em> pivots are the smallest or the largest element of <em>remaining partitioned</em> array.</p>\n\n<p>To better understand the worst case: Think about an already sorted array, which you may be trying to sort. </p>\n\n<p>You select first element as first pivot. After comparing the rest of the array, you would find that the <code>n-1</code> elements <em>still</em> are on the other end (rightside) and the first element remains at the same position, which actually totally beats the <strong>purpose of partitioning</strong>. These steps you would keep repeating till the last element with <em>the same effect</em>, which in turn would account for <code>(n-1 + n-2 + n-3 + ... + 1)</code> comparisons, and that sums up to <code>(n*(n-1))/2</code> comparisons. So, </p>\n\n<pre><code>O(n*(n-1)/2) = O(n^2) for worst case.\n</code></pre>\n\n<p>To overcome this problem, it is always recommended to <em>pick up each successive pivots <strong>randomly</em></strong>.</p>\n\n<p>I would try to add explanation for average case as well.</p>\n", "last_activity_date": 1477646099, "answer_id": 40299480, "is_accepted": false, "owner": {"user_id": 1465553, "reputation": 1444, "user_type": "registered", "accept_rate": 75, "display_name": "Saurav Sahu", "link": "http://stackoverflow.com/users/1465553/saurav-sahu", "profile_image": "https://www.gravatar.com/avatar/5b559f395549789c041652429444dc0a?s=128&d=identicon&r=PG"}, "last_edit_date": 1477646099, "question_id": 40298538}