{"title": "iOS - AWS MobileHub sign in with developer authenticated provider", "tags": ["ios", "objective-c", "iphone", "amazon-web-services", "aws-mobilehub"], "creation_date": 1477501078, "score": 3, "body": "<p>Your question exposes certain terminology problems:</p>\n\n<ul>\n<li>When you say <strong><em>developer</em></strong> I am not sure you mean the same thing that AWS\nmeans.\n\n<ul>\n<li>AWS use the term \"developer\" (as in \"developer identities\") to mean<br>\nexternally maintained pools as opposed to privately maintained.  AWS\nhas    it's own product (Cognito User Pools) which you can privately\nmaintain as an AWS service. AWS does not consider user pools to be a\ndeveloper identity provider (but in practice, it is simply a fully implement renamed version of a developer identity provider).</li>\n</ul></li>\n<li>Regarding maintaining tokens\n\n<ul>\n<li>The IOS SDK maintains the tokens you need for access to AWSServices.\nYou should use the Mobile Hub, (it has a much nicer object and\ninterface design than the SDK).  But regardless of whether you use\nmobile-hub-helper or the SDK directly,  you never have to manage a\ntoken (the SDK does it for you). The documentation (almost cruelly) obscures this fact (and yes, it is lagging behind the SDK). </li>\n</ul></li>\n</ul>\n\n<p><strong>3 ways to use Cognito</strong></p>\n\n<p>You must understand that there are 3 different interface apis.</p>\n\n<ol>\n<li>COGNITO API and <strong>up to date</strong> API documentation (the RESTFUL interaction)</li>\n<li>ISO SDK and <strong>out of date</strong> SDK documentation (the SDK is not RESTFUL, it has ton's of state).</li>\n<li>Mobile Hub Helper (MHH) SDK - MHH is documented (a little) by the hub, and pretty well in the .h files used to produce appledoc documentation.</li>\n</ol>\n\n<p>With respect to Identity and SignIn/Authentication (the topics of this question) aws-mobile-hub-helper (hereafter MHH) has an elegant design and works well. I would recommend anyone using Cognito start with the Mobile Hub site (or at least with aws-mobile-hub-helper). The MHH is basically a wrapper to the SDK and helps clarify and separate the issues of <strong><em>persistent federated identity and credentials/authorization for AWS services</em></strong> from issues of <strong><em>Identity, authentication and attributes/claims for that Identity</em></strong>.</p>\n\n<ul>\n<li>Identity in MHH has only 1 class <strong>AWSIdentityManager</strong>.</li>\n<li>SignIn in MHH has one protocol, <strong>AWSSignInProvider</strong>, and two implementations of that protocol (plus one I made):\n\n<ol>\n<li><strong>AWSGoogleSignInProvider</strong>: OpenID-Connect/OAuth implementation of\nAWSSignInProvider for Google+</li>\n<li><strong>AWSFacebookSignInProvider</strong>: An OAuth/Proprietary implementation of AWSSignInProvider for Facebook</li>\n<li><strong>AWSCUPIdPSignInProvider</strong>: OpenID-Connect/OAuth implementation of\nAWSSignInProvider for Amazon AWS Cognito Your User Pools service (this is available on a forked repository)</li>\n</ol></li>\n</ul>\n\n<p>The mobile-hub-helper is documented only in the .h files.  These can be processed into documentation by appledocs, and the comments there are pretty good if you had an overview of the class structure (which does not exist but I will attempt to provide).</p>\n\n<p><strong>SDK Authentication Flow</strong></p>\n\n<p>The authentication flow documented by AWS, is an oversimplification and does not aid in understanding how the authentication is accomplished using the SDK and Mobile Hub Helper.  The following diagrams attempt to convey how identity authentication(login) and authorization(credentials) to use AWS Services (like S3, and DynamoDB) works.</p>\n\n<p><a href=\"https://i.stack.imgur.com/CYnj9.jpg\" rel=\"nofollow\"><img src=\"https://i.stack.imgur.com/CYnj9.jpg\" alt=\"Cognito SDK Authentication Flow (Single Identity Provider)\"></a>\n<a href=\"https://i.stack.imgur.com/h6fBN.jpg\" rel=\"nofollow\"><img src=\"https://i.stack.imgur.com/h6fBN.jpg\" alt=\"Cognito SDK Authentication Flow (Multiple Identity Provider)\"></a></p>\n\n<p><strong>Understanding Cognito</strong></p>\n\n<ul>\n<li>Understanding Cognito is initially confusing for a variety of<br>\nreasons: Authentication, Authorization and Identity Management in a<br>\ndistributed system is complex. There are many parties with different \nroles and elaborate prescribed interactions with keys, tokens and<br>\nsignatures.  The end user, the relying party (RP) the Identity<br>\nProvider (IdP) the resource being used (RS) and the resource owner<br>\n(RO). This terminology is used by the OpenId Connect and OAuth2.0<br>\nstandards documents.  For reasons that will become clear, this<br>\nterminology is not consistently used by AWS.  But they concepts and<br>\nthe entities are all there when using Cognito.\n\n<ul>\n<li>There are some good    OpenID connect overviews online (ex:       <a href=\"http://nordicapis.com/api-security-oauth-openid-connect-depth/\" rel=\"nofollow\">http://nordicapis.com/api-security-oauth-openid-connect-depth/</a> ) and \na review of those will help.</li>\n</ul></li>\n<li>Cognito allows <strong>non-OpenID Connect</strong>    Identity Providers, this is\nan    advantage (ex: allowing the OAuth/Proprietary Facebook identity\nAPI) but it also means that Cognito is playing a \u201cfederating\u201d<br>\nrole.  This role is outside the scope of OpenID Connect standards<br>\ndocuments (Update 1: Lately I have begun to wonder whether the\nCognito Credentials Provider is really the RP (Relying Party) which\nthen issues credentials for AWS Services.  But the main point here is\nthat OpenId Connect does not prescribe the way that Identities from\ndifferent IdP's could be combined.), Amazon are essentially inventing\nthe role, and in    doing so have had some naming challenges.</li>\n</ul>\n\n<p><strong>Cognito Naming</strong></p>\n\n<ul>\n<li><p>Cognito is a single name created by AWS to cover many functionalities\nand roles.</p>\n\n<ol>\n<li>There is the RESTFUL web API to Cognito, but there is also the<br>\nCognito SDK. The SDK calls and the API messages are not named the<br>\nsame, and SDK calls make multiple and conditional API calls.</li>\n<li>Cognito    can federate identity providers. It can persist and<br>\nassociation    betwene authenticated users from different identity<br>\nproviders (So it    can remember your google+ and your facebook<br>\nidentities and associated    them with a single Cognito identityId.)</li>\n<li>Cognito can provide    persistent identityId (which, if anonymous,\nfollow an IOS device    using keychain data) for users as well as\nauthenticated users. These    are stored in what is called an\nIdentity Pool (NOT to be confused    with a User Pool). Your app\nreceives the same identityId for a user    on different devices for\nauthenticated users. Unauthenticated (Guest)    identityId\u2019s follow a\nsingle device.</li>\n<li>Cognito can store (known as    \u201cSync\u201d) state data IdentityId\u2019s (on\nthe AWS server), which works for    authenticated and unauthenticated\nusers.</li>\n<li>Cognito has a    AWSCredentialsProvider (a source for AWS Credentials\nfor using AWS    Services (Cognito but also S3, DynamoDB, etc)</li>\n<li>Cognito can create an    OpenID Connect server called a User Pool,\nwhich can be used by    Cognito Identity to Authenticate users.</li>\n<li>Cognito is new, but AWS Federated Identities and AWS Identity\nManagement and AWS Credentials are not, so there are lots of classes\nwith overlapping responsibility.  And the naming conventions are\nconfusing (consider the name\nAWSCognitoIdentityCognitoIdentityProvider! ). The use of the \u201ccognito\u201d\nbrand name for userpools, really is a nightmare.  An\nAWSCognitoIdentity thing is Cognito Federated Identity CFI but an\nAWSCognitoIdentityProvider thing is a thing like userpools an\nauthentication provider also called an identity provider.</li>\n</ol></li>\n<li><p>SDK class names are confusing. But with few exceptions, classes starting with <strong>AWSCognitoIdentity</strong> (but NOT AWSCognitoIdentityProvider) are about the credentialsProvider/IdentityProvider, classes starting with <strong>AWSCognitoIdentityProvider</strong> relate to Oauth/Open Id Connect providers and other distributed identity providers (facebook).</p></li>\n</ul>\n\n<p><strong>Glossary/Synonyms</strong></p>\n\n<p>These terms are used loosely throughout the AWS documentation and marketing material.  This is an attempt to sort out the terminology by grouping terms that are used interchangeably by AWS.</p>\n\n<ul>\n<li>Identity provider, authentication provider, Login provider, federated\nidentity provider(s)</li>\n<li>Amazon Cognito, Cognito credentials provider, cognito identity (all\nseem to refer to the same class/process)</li>\n<li>Cognito user pool, Cognito Your User Pools, user pool. CUP <strong>is</strong> an identity provider aka authentication provider</li>\n<li>Cognito identity pool, pool, cognito pool, identity pool. Occasionally called an identity provider (which seems incorrect) but it is never called an authentication provider</li>\n<li>Developer identity, developer authenticated identities, developer\nprovider, developer identity provider, all used to refer to private external Identity Providers.</li>\n<li>Identity is a term often misused in Cognito documentation.  It is important to understand there are two different kinds of identity that Cognito manages. <strong>identityId</strong> (which should be in lower case) is the persistent unique name that Cognito associates with credentials and uses to federate different <strong>Identity</strong> providers, and Identity (upper case) which is an authenticated identifier from an Identity Provider.</li>\n<li><strong>identityId</strong> Identity ID, id (as in get-id), identity, identityId</li>\n<li><strong>Identity</strong>   </li>\n<li>Federation means multiple things.  </li>\n<li>Web identity federation - an earlier way of federating identity at AWS</li>\n<li>Cognito federated identities</li>\n<li>BYOI (bring your own idenity) where a user may use google, facebook or another identity provider (perhaps a developer provided identity) usually through OpenId-Connect.  </li>\n</ul>\n\n<p><strong>IdentityId Behaviors</strong></p>\n\n<ul>\n<li>An identity id looks something like this:\nus-east-1:982396fs-841e-3cdd-9r43-e7ac41bhbcb28</li>\n<li>The identityId is maintained on an IOS device in a keychain entry.\nFor an unauthenticated IdentityId it remains the same until you clear\nthe keychain (This can be done in simulator by Simulator ->  Reset\nContent and Settings\u2026).  At that point that IdentityId is abandoned.\nIt is not disabled, it is just never used again.</li>\n<li><p>When the user authenticates, authenticating disables the unauthenticated identityId (the\nidentityId will be permanently marked with DISABLED in the Logins array in the\nidentityPool entry. You can see this in the Cognito console.) that is\ncurrently on the device.  There is one exception: If this is the first time the\nauthentication takes place for this Identity then the unauthenticated identityId is not abandoned but\nis associated with the Identity and used as the authenticated\nidentityID going forward.</p></li>\n<li><p>Merging multiple Identities (meaning usernames not IdentityId\u2019s) from\ndifferent Identity providers abandons (disables) one of the identityId's, and\nassociates both Identities with the other identityId. Disabled\nId\u2019s get created whenever this happens. These abandoned identityId's are marked with DISABLED in the Logins array in\nthe cognito identityPool.</p></li>\n<li><p>In practice this process creates a reasonable use of unique identityIds with\ndisabled ones only getting created when a user authenticates on a new\ndevice (It can be bothersome in testing as it creates a barrage of\ndisabled and unused identityId\u2019s as the tester logs out and in\nmultiple times with multiple id\u2019s). But in practice the common use case would not create this barrage of disabled identityIds. A user would: </p></li>\n<li><p>Connect \u2013 get an unauthenticated id - authenticate \u2013 and use the same\nID. No abandoned id is created.</p></li>\n<li>Connect on another device \u2013 here he/she would momentarily get a new\nunauthenticated id \u2013 and when he/she authenticated and got the\nidentityId for his/her identity, that unauthenticated id would be\ndisabled and abandoned.</li>\n<li>Each merging of identities from two identity providers would also\ncreate a disabled and abandoned identityId.</li>\n</ul>\n\n<p><strong>AWSIdentityProviderManager</strong></p>\n\n<ul>\n<li><p>AWSIdentityProviderManager is the protocol that manages federated AWSIdentityProviders</p></li>\n<li><p>In mobile-hub-helper AWSIdentityManager is the AWSIdentityProviderManager</p>\n\n<ul>\n<li><p>All it needs to do is return to credentials provider    a logins\ndictionary, with providers name and ID Token.  AWSIdentityManager\nonly returns the providername and    token for a single identity\nprovider. It simply gets the name and token from the\nAWSSignInProvider and returns.  (There is a <a href=\"https://github.com/BruceBuckland/aws-mobilehub-helper-ios\" rel=\"nofollow\">fork</a> with a modification\nthat adds the ability to return all of the current logged in\nproviders in the logins dictionary.)</p></li>\n<li><p>As modified AWSIdentityManager maintains an NSDictionary\ncalled cachedLogins. Each new login adds an login (an identity\nprovider name and id token) to the cache. Then logins always returns\nthe whole loginCache.  This is what supports identity merging.</p></li>\n</ul></li>\n<li><p>When the credentials provider calls it\u2019s associated\nAWSIdentityProviderManager logins method, and finds a list of\nlogins instead of just one it will merge the identityId's for those logins\nin it\u2019s database and disable the identityId of one of them.  How does\nit know which ID goes with which login?  The ID Token contains an\nencoded decryptable (paste the token into <a href=\"https://jwt.io\" rel=\"nofollow\">https://jwt.io</a> to see for\nyourself) set of claims, one of which is the identity (ex: username)</p></li>\n<li><p>Note: Even though you have an identityId that has multiple related logins, in Mobile Hub Helper you are only ever authenticated by one AWSSignInProvider.  Credentials get associated with the merged identityId, but in mobile-hub-helper access to that identityId is always via the active AWSSignInProvider (authentication provider) even if you are logged with multiple identity providers.  Your app can keep track of all of the AWSSignInProviders and access them independently of AWSIdentityManager, but from AWSIdentityManagers point of view you are logged in with one of them. In practice this has little impact (until you try to get \"claims\" like imageURL from different providers for instance).</p></li>\n</ul>\n\n<p><strong>About Merging Identities</strong></p>\n\n<ul>\n<li><p>Currently the AWSIdentityManager does not support identity merging. I have a <a href=\"https://github.com/BruceBuckland/aws-mobilehub-helper-ios\" rel=\"nofollow\">forked repository https://github.com/BruceBuckland/aws-mobilehub-helper-ios</a> from the github repository that adds that capability, and adds a Cognito User Pools Identity Provider AWSSignInProvider (AWSCUPIdPSignInProvider.swift). </p></li>\n<li><p>You can probably think of all sorts of gotcha\u2019s when merging\nidentities.</p></li>\n<li><p>What if I try to merge two identities from the same provider\n(wouldn\u2019t the dictionary keys be the same?)</p></li>\n<li><p>What if I try to merge two identities, each of which has a different\nidentity from the same provider associated with it (and again they\nwould create two entities with the same keys).</p></li>\n<li><p>Cognito manages this beautifully and rejects attempts to merge<br>\nidentites that cannot be merged.  The rejection happens at login time\n(when you would try get credentials, the credentials provider will\nreject the logins dictionary that contains an un-mergeable\nidentityId)</p></li>\n</ul>\n\n<p><strong>Where Cognito buries its data</strong></p>\n\n<ul>\n<li><p>Cognito stores a keychain on the device that contains the last identityId that was used. This is used by the credentialsProvider/identityProvider object upon a call to credentialsProvider.credentials (IOS SDK name) to re-use an existing identity (for example unauthenticated) and avoid creating unused identities unless the user truly is not going to log in or resume.</p></li>\n<li><p>Mobile-Hub-Helper\u2019s AWSSignInProvider\u2019s and AWSIdentityManager store an indication of an open session state in NSUserDefaults.  These are used to re-start the session if the app is terminated and restarted.</p></li>\n<li><p>AWSSignInProvider\u2019s store NSUserDefaults too, and sometimes in the IOS Keychain, for their own internal purposes (like retaining easy persistent access to a username or imageURL or token)</p></li>\n</ul>\n", "last_activity_date": 1477687620, "answer_id": 40268100, "is_accepted": true, "owner": {"user_id": 6491337, "reputation": 163, "user_type": "registered", "display_name": "Bruce0", "link": "http://stackoverflow.com/users/6491337/bruce0", "profile_image": "https://i.stack.imgur.com/OBTBd.png?s=128&g=1"}, "last_edit_date": 1477687620, "question_id": 37260766}