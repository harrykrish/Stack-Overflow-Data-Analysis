{"title": "Java Graphs: Easy Declaration", "tags": ["java", "graph"], "creation_date": 1477790455, "score": -1, "body": "<p>this is pretty useful .. it is a tutorial from princeton university .. follow the code line by line and it should be clear ..  </p>\n\n<p><a href=\"http://algs4.cs.princeton.edu/41graph/Graph.java.html\" rel=\"nofollow\">http://algs4.cs.princeton.edu/41graph/Graph.java.html</a></p>\n\n<pre><code>public class Graph {\nprivate static final String NEWLINE = System.getProperty(\"line.separator\");\n\nprivate final int V;\nprivate int E;\nprivate Bag&lt;Integer&gt;[] adj;\n\n/**\n * Initializes an empty graph with {@code V} vertices and 0 edges.\n * param V the number of vertices\n *\n * @param  V number of vertices\n * @throws IllegalArgumentException if {@code V &lt; 0}\n */\npublic Graph(int V) {\n    if (V &lt; 0) throw new IllegalArgumentException(\"Number of vertices must be nonnegative\");\n    this.V = V;\n    this.E = 0;\n    adj = (Bag&lt;Integer&gt;[]) new Bag[V];\n    for (int v = 0; v &lt; V; v++) {\n        adj[v] = new Bag&lt;Integer&gt;();\n    }\n}\n\n/**  \n * Initializes a graph from an input stream.\n * The format is the number of vertices &lt;em&gt;V&lt;/em&gt;,\n * followed by the number of edges &lt;em&gt;E&lt;/em&gt;,\n * followed by &lt;em&gt;E&lt;/em&gt; pairs of vertices, with each entry separated by whitespace.\n *\n * @param  in the input stream\n * @throws IndexOutOfBoundsException if the endpoints of any edge are not in prescribed range\n * @throws IllegalArgumentException if the number of vertices or edges is negative\n */\npublic Graph(In in) {\n    this(in.readInt());\n    int E = in.readInt();\n    if (E &lt; 0) throw new IllegalArgumentException(\"Number of edges must be nonnegative\");\n    for (int i = 0; i &lt; E; i++) {\n        int v = in.readInt();\n        int w = in.readInt();\n        addEdge(v, w);\n    }\n}\n\n/**\n * Initializes a new graph that is a deep copy of {@code G}.\n *\n * @param  G the graph to copy\n */\npublic Graph(Graph G) {\n    this(G.V());\n    this.E = G.E();\n    for (int v = 0; v &lt; G.V(); v++) {\n        // reverse so that adjacency list is in same order as original\n        Stack&lt;Integer&gt; reverse = new Stack&lt;Integer&gt;();\n        for (int w : G.adj[v]) {\n            reverse.push(w);\n        }\n        for (int w : reverse) {\n            adj[v].add(w);\n        }\n    }\n}\n\n/**\n * Returns the number of vertices in this graph.\n *\n * @return the number of vertices in this graph\n */\npublic int V() {\n    return V;\n}\n\n/**\n * Returns the number of edges in this graph.\n *\n * @return the number of edges in this graph\n */\npublic int E() {\n    return E;\n}\n\n// throw an IndexOutOfBoundsException unless {@code 0 &lt;= v &lt; V}\nprivate void validateVertex(int v) {\n    if (v &lt; 0 || v &gt;= V)\n        throw new IndexOutOfBoundsException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n}\n\n/**\n * Adds the undirected edge v-w to this graph.\n *\n * @param  v one vertex in the edge\n * @param  w the other vertex in the edge\n * @throws IndexOutOfBoundsException unless both {@code 0 &lt;= v &lt; V} and {@code 0 &lt;= w &lt; V}\n */\npublic void addEdge(int v, int w) {\n    validateVertex(v);\n    validateVertex(w);\n    E++;\n    adj[v].add(w);\n    adj[w].add(v);\n}\n\n\n/**\n * Returns the vertices adjacent to vertex {@code v}.\n *\n * @param  v the vertex\n * @return the vertices adjacent to vertex {@code v}, as an iterable\n * @throws IndexOutOfBoundsException unless {@code 0 &lt;= v &lt; V}\n */\npublic Iterable&lt;Integer&gt; adj(int v) {\n    validateVertex(v);\n    return adj[v];\n}\n\n/**\n * Returns the degree of vertex {@code v}.\n *\n * @param  v the vertex\n * @return the degree of vertex {@code v}\n * @throws IndexOutOfBoundsException unless {@code 0 &lt;= v &lt; V}\n */\npublic int degree(int v) {\n    validateVertex(v);\n    return adj[v].size();\n}\n\n\n/**\n * Returns a string representation of this graph.\n *\n * @return the number of vertices &lt;em&gt;V&lt;/em&gt;, followed by the number of edges &lt;em&gt;E&lt;/em&gt;,\n *         followed by the &lt;em&gt;V&lt;/em&gt; adjacency lists\n */\npublic String toString() {\n    StringBuilder s = new StringBuilder();\n    s.append(V + \" vertices, \" + E + \" edges \" + NEWLINE);\n    for (int v = 0; v &lt; V; v++) {\n        s.append(v + \": \");\n        for (int w : adj[v]) {\n            s.append(w + \" \");\n        }\n        s.append(NEWLINE);\n    }\n    return s.toString();\n}\n\n\n/**\n * Unit tests the {@code Graph} data type.\n *\n * @param args the command-line arguments\n */\npublic static void main(String[] args) {\n    In in = new In(args[0]);\n    Graph G = new Graph(in);\n    StdOut.println(G);\n}\n</code></pre>\n\n<p>}</p>\n", "last_activity_date": 1477799599, "answer_id": 40325217, "is_accepted": false, "owner": {"user_id": 6943086, "reputation": 9, "user_type": "registered", "display_name": "ninja man", "link": "http://stackoverflow.com/users/6943086/ninja-man", "profile_image": "https://www.gravatar.com/avatar/48760da584ad2fcb97d7511490822b47?s=128&d=identicon&r=PG&f=1"}, "last_edit_date": 1477799599, "question_id": 40325196}