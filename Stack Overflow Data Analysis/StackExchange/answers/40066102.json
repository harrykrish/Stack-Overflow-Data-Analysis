{"body": "<p>The short answer to your question is no.</p>\n\n<p>The ability to define a base type for enumerations is a language feature that was not added until C++11 (<a href=\"http://en.cppreference.com/w/cpp/language/enum\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/enum</a>). Unfortunately, WindRiver has been slow to support compilers that comply with modern C++ standards (<a href=\"http://stackoverflow.com/questions/36309858/c-11-in-vxworks\">C++ 11 in vxworks</a>). There is mention of support for C++11 in commercial versions of g++ for VxWorks 7.0+ (<a href=\"http://stackoverflow.com/a/36311473\">http://stackoverflow.com/a/36311473</a>). But, your WorkBench version (&lt;4.0) implies that this won't be helpful to you.</p>\n\n<p>In your situation, I might cobble together a work-around, such as this:</p>\n\n<pre><code>namespace FRUIT_E\n{\n    static const UINT16 APPLE = 0;\n    static const UINT16 LEMON = 1;\n    static const UINT16 GRAPE = 2;\n}\n\ntypedef FRUIT_T UINT16;\n\n...\n\nFRUIT_T fruit = FRUIT_E::APPLE;\n</code></pre>\n\n<p>However, this won't provide type safety, as FRUIT_T is just an alias for UINT16. So, it's far from ideal. I've added tags to your question. There may be better work-arounds, emulating the desired behavior more closely. But, the addition of a new language feature would seem to indicate that existing methods were inadequate.</p>\n", "tags": ["c++", "c++11", "vxworks", "wind-river-workbench"], "creation_date": 1476583406, "score": 2, "last_activity_date": 1476583406, "answer_id": 40066102, "is_accepted": true, "owner": {"user_id": 1204259, "reputation": 170, "user_type": "registered", "display_name": "Cliff Bilbrey", "link": "http://stackoverflow.com/users/1204259/cliff-bilbrey", "profile_image": "https://i.stack.imgur.com/Lmpyx.jpg?s=128&g=1"}, "title": "Enum with datatype in WindRiver Workbench 3.3", "question_id": 40006435}