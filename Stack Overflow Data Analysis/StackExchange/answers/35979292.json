{"title": "Couldn&#39;t connect to Docker daemon on Mac OS X", "tags": ["osx", "docker", "docker-compose"], "creation_date": 1457927837, "score": 10, "body": "<p><a href=\"http://stackoverflow.com/a/35977975/45375\">Kevan Ahlquist's helpful answer</a> shows what commands to add to your Bash profile (<code>~/.bash_profile</code>) to automatically initialize Docker on opening an interactive shell.</p>\n\n<p><sup>Note that you can always initialize Docker in a <em>new</em> shell tab/window by opening application <code>/Applications/Docker/Docker Quickstart Terminal.app</code> (e.g., via Spotlight).<br>\nFrom an existing shell, you can invoke it as <code>open -a 'Docker Quickstart Terminal.app'</code> (which also opens a <em>new</em> shell tab).<br>\nWhat this answer offers is a convenient way to start Docker in the <em>current</em> shell.</sup></p>\n\n<p>Adding the Bash <strong>shell functions</strong> below - <code>docker-start</code> and <code>docker-stop</code> - improves on Kevan's approach in the following respects:</p>\n\n<ul>\n<li><p>You can run <code>docker-start</code> <em>on demand</em>, without the overhead of starting the VM on <em>opening</em> the shell (once the Docker VM is running, initialization is much faster, but still takes a noticeable amount of time).<br>\n(Of course, you can still opt to invoke <code>docker-start</code> right from your profile.)</p></li>\n<li><p><code>docker-stop</code> allows stopping Docker and cleaning up the environment variables on demand.</p></li>\n<li><p>The functions ensure that Docker's error messages are not suppressed, and they pass Docker error exit codes through.</p></li>\n<li><p>Additional status information is provided.</p></li>\n<li><p>You may pass a VM name as a parameter; default is <code>default</code>.</p></li>\n</ul>\n\n<p>Example:</p>\n\n<pre><code>$ docker-start\n-- Starting Docker VM 'default' (`docker-machine start default`; this will take a while)...\nStarting \"default\"...\n(default) Check network to re-create if needed...\n(default) Waiting for an IP...\nMachine \"default\" was started.\nWaiting for SSH to be available...\nDetecting the provisioner...\nStarted machines may have new IP addresses. You may need to re-run the `docker-machine env` command.\n-- Setting DOCKER_* environment variables (`eval \"$(docker-machine env default)\"`)...\nDOCKER_CERT_PATH=\"/Users/jdoe/.docker/machine/machines/default\"\nDOCKER_HOST=\"tcp://192.168.99.100:2376\"\nDOCKER_MACHINE_NAME=\"default\"\nDOCKER_TLS_VERIFY=\"1\"\n-- Docker VM 'default' is running.\n\n\n$ docker-stop\n-- Stopping Docker VM 'default' (`docker-machine stop default`)...\nStopping \"default\"...\nMachine \"default\" was stopped.\n-- Unsetting DOCKER_* environment variables (DOCKER_CERT_PATH, DOCKER_HOST, DOCKER_MACHINE_NAME, DOCKER_TLS_VERIFY)...\n-- Docker VM 'default' is stopped.\n</code></pre>\n\n<hr>\n\n<p><strong>Shell functions for on-demand starting and stopping of Docker</strong> (place them in, e.g.,  <code>~/.bash_profile</code> for global availability in your interactive shells).</p>\n\n<p><strong>Note</strong>: The functions work in <code>bash</code>, <code>ksh</code>, and <code>zsh</code>, but in <code>ksh</code> you have to rename them so as not to include a '-' in the function names.</p>\n\n<pre class=\"lang-sh prettyprint-override\"><code>function docker-start {\n  typeset vm=${1:-default} sts\n  case $vm in\n    -h|--help)\n      echo $'usage: docker-start [&lt;vm&gt;]\\n\\nEnsures that the specified/default Docker VM is started\\nand the environment is initialized.'\n      return 0\n      ;;\n  esac\n  sts=$(docker-machine status \"$vm\") || return\n  [[ $sts == 'Running' ]] &amp;&amp; echo \"(Docker VM '$vm' is already running.)\" || { \n    echo \"-- Starting Docker VM '$vm' (\\`docker-machine start \"$vm\"\\`; this will take a while)...\"; \n    docker-machine start \"$vm\" || return\n  }\n  echo \"-- Setting DOCKER_* environment variables (\\`eval \\\"\\$(docker-machine env \"$vm\")\\\"\\`)...\"\n  # Note: If the machine hasn't fully finished starting up yet from a\n  #       previously launched-but-not-waited-for-completion `docker-machine status`,\n  #       the following may output error messages; alas, without signaling failure\n  #       via the exit code. Simply rerun this function to retry.\n  eval \"$(docker-machine env \"$vm\")\" || return\n  export | grep -o 'DOCKER_.*'\n  echo \"-- Docker VM '$vm' is running.\"\n}\n\nfunction docker-stop {\n  typeset vm=${1:-default} sts envVarNames fndx\n  case $vm in\n    -h|--help)\n      echo $'usage: docker-stop [&lt;vm&gt;]\\n\\nEnsures that the specified/default Docker VM is stopped\\nand the environment is cleaned up.'\n      return 0\n      ;;\n  esac\n  sts=$(docker-machine status \"$vm\") || return\n  [[ $sts == 'Running' ]] &amp;&amp; { \n    echo \"-- Stopping Docker VM '$vm' (\\`docker-machine stop \"$vm\"\\`)...\";\n    docker-machine stop \"$vm\" || return\n  } || echo \"(Docker VM '$vm' is not running.)\"\n  [[ -n $BASH_VERSION ]] &amp;&amp; fndx=3 || fndx=1 # Bash prefixes defs. wit 'declare -x '\n  envVarNames=( $(export | awk -v fndx=\"$fndx\" '$fndx ~ /^DOCKER_/ { sub(/=.*/,\"\", $fndx); print $fndx }') )\n  if [[ -n $envVarNames ]]; then\n    echo \"-- Unsetting DOCKER_* environment variables ($(echo \"${envVarNames[@]}\" | sed 's/ /, /g'))...\"\n    unset \"${envVarNames[@]}\"\n  else\n    echo \"(No DOCKER_* environment variables to unset.)\"\n  fi\n  echo \"-- Docker VM '$vm' is stopped.\"\n}\n</code></pre>\n", "last_activity_date": 1477718106, "answer_id": 35979292, "is_accepted": true, "owner": {"user_id": 45375, "reputation": 47202, "user_type": "registered", "display_name": "mklement0", "link": "http://stackoverflow.com/users/45375/mklement0", "profile_image": "https://www.gravatar.com/avatar/39f6e2dc52425b1e08027c01bb880be0?s=128&d=identicon&r=PG"}, "last_edit_date": 1477718106, "question_id": 35969414}