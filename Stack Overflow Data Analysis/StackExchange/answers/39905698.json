{"title": "TypeScript &quot;this&quot; scoping issue when called in jquery callback", "tags": ["typescript"], "creation_date": 1475788296, "score": 1, "body": "<p>Another solution that requires some initial setup but pays off with its invincibly light, literally one-word syntax is using <a href=\"https://github.com/Microsoft/TypeScript-Handbook/blob/master/pages/Decorators.md#method-decorators\" rel=\"nofollow\">Method Decorators</a> to JIT-bind methods through getters.</p>\n\n<p>I've created a <a href=\"https://github.com/JohnWhiteTB/BoundMethods/blob/master/src/bound.ts\" rel=\"nofollow\">repo on GitHub</a> to showcase an implementation of this idea <em>(it's a bit lengthy to fit into an answer with its 40 lines of code, including comments)</em>, that you would use as simply as:</p>\n\n<pre><code>class DemonstrateScopingProblems {\n    private status = \"blah\";\n\n    @bound public run() {\n        alert(this.status);\n    }\n}\n</code></pre>\n\n<p>I haven't seen this mentioned anywhere yet, but it works flawlessly. Also, there is no notable downside to this approach: the implementation of this decorator -- <em>including some type-checking for runtime type-safety</em> -- is trivial and straightforward, and comes with essentially zero overhead after the initial method call.</p>\n\n<p>The essential part is defining the following getter on the class prototype, which is executed <em>immediately before</em> the first call:</p>\n\n<pre><code>get: function () {\n    // Create bound override on object instance. This will hide the original method on the prototype, and instead yield a bound version from the\n    // instance itself. The original method will no longer be accessible. Inside a getter, 'this' will refer to the instance.\n    var instance = this;\n\n    Object.defineProperty(instance, propKey.toString(), {\n        value: function () {\n            // This is effectively a lightweight bind() that skips many (here unnecessary) checks found in native implementations.\n            return originalMethod.apply(instance, arguments);\n        }\n    });\n\n    // The first invocation (per instance) will return the bound method from here. Subsequent calls will never reach this point, due to the way\n    // JavaScript runtimes look up properties on objects; the bound method, defined on the instance, will effectively hide it.\n    return instance[propKey];\n}\n</code></pre>\n\n<p><a href=\"https://github.com/JohnWhiteTB/BoundMethods/blob/master/src/bound.ts\" rel=\"nofollow\">Full source</a></p>\n\n<hr>\n\n<p>The idea can be also taken one step further, by doing this in a class decorator instead, iterating over methods and defining the above property descriptor for each of them in one pass.</p>\n", "last_activity_date": 1476870413, "answer_id": 39905698, "is_accepted": false, "owner": {"user_id": 2788872, "reputation": 3682, "user_type": "registered", "accept_rate": 86, "display_name": "John White", "link": "http://stackoverflow.com/users/2788872/john-white", "profile_image": "https://www.gravatar.com/avatar/a2616878b8bfb95d8fbb8a63ad18d729?s=128&d=identicon&r=PG&f=1"}, "last_edit_date": 1476870413, "question_id": 20627138}