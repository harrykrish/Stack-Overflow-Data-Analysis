{"body": "<pre><code>#!/usr/bin/env node\n\n'use strict';\n\nconst stream = require('stream');\n\n// This is an example of a 'readable' stream that has to go through a multi-\n// step process to finally get the actual readable stream. So we are\n// asynchronously wrapping another readable stream.\n\n// The key to simplicity here was to use a transform stream instead of a\n// readable stream because it allows us to pipe the stream to ourselves.\nclass ReadableWrappingTransform extends stream.Transform {\n  constructor() {\n    super({\n      objectMode: true,\n      // Our _transform method doesn't really do anything and we don't want to\n      // hog up any more additional memory than necessary.\n      highWaterMark: 1\n    });\n    process.nextTick(() =&gt; {\n      if (new Date().getTime() % 5 === 1) {\n\n        // Here we simulate an error that happened somewhere in the multi-step\n        // process to get the final stream. So we just emit 'error' and we're\n        // done.\n        this.emit('error', new Error('Could not get the stream.'));\n\n        //Assuming based on the node docs that we should not emit\n        // 'close' or 'end' on error. If we do emit 'end', it will trigger the\n        // writable's 'finish' event, which is probably not desired. You either\n        // want an 'error' OR a 'finish'.\n\n        // NODE END EVENT DOCS\n        // The 'end' event is emitted when there is no more data to be consumed\n        // from the stream.\n\n        // Note: The 'end' event will not be emitted unless the data is\n        // completely consumed. This can be accomplished by switching the stream\n        // into flowing mode, or by calling stream.read() repeatedly until all\n        // data has been consumed.\n\n        // this.emit('end');\n\n        // NODE CLOSE EVENT DOCS\n        // The 'close' event is emitted when the stream and any of its\n        // underlying resources (a file descriptor, for example) have been\n        // closed. The event indicates that no more events will be emitted, and\n        // no further computation will occur.\n\n        // Not all Readable streams will emit the 'close' event.\n\n        // this.emit('close');\n      } else {\n        // We successfully got the stream we wanted after a long, hard, multi-\n        // step process, so first we need to copy all our listeners over to it\n        // -- NOT.\n\n        // ['close', 'data', 'end', 'error'].forEach((eventName) =&gt; {\n        //   this.listeners(eventName).forEach((l) =&gt; {\n        //     readable.on(eventName, l);\n        //   });\n        // });\n\n        // Turns out that .pipe propagates ALL listeners EXCEPT the 'error'\n        // listener. What's up with that !?! If we copy any of the others  we\n        // get double the events -- including double the data. So here we just\n        // copy over the 'error' listener to make sure we get 'error' events.\n        ['error'].forEach((eventName) =&gt; {\n          this.listeners(eventName).forEach((l) =&gt; {\n            readable.on(eventName, l);\n          });\n        });\n\n        // Then just pipe the final readable to ourselves, and we are good.\n        readable\n          .pipe(this);\n      }\n    });\n  }\n  _transform(data, encoding, callback) {\n    // Nothing special to do here just pass along the data.\n    this.push(data);\n    callback();\n  }\n}\n\n// This is just a very unreliable test readable stream.\nconst readable = new stream.Readable({\n  objectMode: true,\n  read() {\n    for (let i = 0; i &lt; 10; i++) {\n      if (new Date().getTime() % 13 === 1) {\n        this.__err = new Error('Sorry, error reading data.');\n        this.emit('error', this.__err);\n        return;\n      }\n      this.push({\n        Name: `Mikey ${i}`\n      });\n    }\n    this.push(null);\n  }\n});\n\n// Any old writable that we can pipe to.\nconst writable = new stream.Writable({\n  objectMode: true,\n  write(chunk, encoding, callback) {\n    console.log(chunk, encoding);\n    callback();\n  }\n});\n\nnew ReadableWrappingTransform()\n  // if your stream emits close you get close.\n  .on('close', () =&gt; {\n    console.error('CLOSE');\n  })\n  // if you push null you get end from read.\n  .on('end', () =&gt; {\n    console.error('END');\n  })\n  // error needs to be both places !?! seriously node?\n  .on('error', (error) =&gt; {\n    console.error('ERROR', error);\n  })\n  // Finish does no good here. It's a writable event.\n  // .on('finish', () =&gt; {\n  //   console.error('FINISH');\n  // })\n  .pipe(writable)\n  // Close and End do no good here, they are readable events.\n  // They are not propagated to the writable.\n  //\n  // // if your stream emits close you get close.\n  // .on('close', () =&gt; {\n  //   console.error('CLOSE');\n  // })\n  // // if you push null you get end from read.\n  // .on('end', () =&gt; {\n  //   console.error('END');\n  // })\n  // error needs to be both places !?! seriously node?\n  .on('error', (error) =&gt; {\n    console.error('ERROR', error);\n  })\n  // you should always get either finish or error or something was done\n  // incorrectly.\n  .on('finish', () =&gt; {\n    console.error('FINISH');\n  });\n</code></pre>\n", "tags": ["node.js", "stream"], "creation_date": 1477745136, "score": 0, "last_activity_date": 1477745136, "answer_id": 40319226, "is_accepted": true, "owner": {"user_id": 634374, "reputation": 190, "user_type": "registered", "accept_rate": 80, "display_name": "john.stein", "link": "http://stackoverflow.com/users/634374/john-stein", "profile_image": "https://www.gravatar.com/avatar/52cf86b0d5c5ca6440c0ed2ab129b336?s=128&d=identicon&r=PG"}, "title": "How can I create a Node.js surrogate readable stream that will wrap another stream that&#39;s not available at the time the surrogate stream was created?", "question_id": 40157776}