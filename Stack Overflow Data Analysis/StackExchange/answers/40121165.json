{"body": "<p>This is basically a limitation of the Java interface for <code>List</code> and <code>LinkedList</code>, rather than a fundamental limitation of linked lists. That is, in Java there is no convenient concept of \"a pointer to a list node\".</p>\n\n<p>Every type of list has a few different concepts loosely associated with the idea of pointing to a particular item:</p>\n\n<ul>\n<li>The idea of a \"reference\" to a specific item in a list</li>\n<li>The integer position of an item in the list</li>\n<li>The value of a item that may be in the list (possibly multiple times)</li>\n</ul>\n\n<p>The most general concept is the first one, and is usually encapsulated in the idea of an <em>iterator</em>. As it happens, the simple way to implement an iterator for an array backed list is simply to wrap an integer which refers to the position of the item in a list. So for array lists only, the first and second ways of referring to items are pretty tightly bound.</p>\n\n<p>For other list types, however, and even for most other container types (trees, hashes, etc) that is <em>not</em> the case. The generic reference to an item is usually something like a pointer to the wrapper structure around one item (e.g., <code>HashMap.Entry</code> or <code>LinkedList.Entry</code>). For these structures the idea of accessing the <em>nth</em> element isn't necessary natural or even possible (e.g., unordered collections like sets and many hash maps).</p>\n\n<p>Perhaps unfortunately, Java made the idea of getting an item by its <em>index</em> a first-class operation. Many of the operations directly on <code>List</code> objects are implemented in terms of list indexes: <code>remove(int index)</code>, <code>add(int index, ...)</code>, <code>get(int index)</code>, etc. So it's kind of natural to think of those operations as being the fundamental ones. </p>\n\n<p>For <code>LinkedList</code> though it's more fundamental to use a pointer to a node to refer to an object. Rather than passing around a list index, you'd pass around the pointer. After inserting an element, you'd get a pointer to the element. </p>\n\n<p>In C++ this concept is embodied in the concept of the <code>iterator</code>, which is the first class way to refer to items in collections, including lists. So does such a \"pointer\" exist in Java? It sure does - it's the <code>Iterator</code> object! Usually you think of an <code>Iterator</code> as being for iteration, but you can also think of it as pointing to a particular object. </p>\n\n<p>So the key observation is: given an pointer (iterator) to an object, you can remove and add from linked lists in <em>constant time</em>, but from an array-like list this takes <em>linear time</em> in general. There is no inherent need to <em>search</em> for an object before deleting it: there are plenty of scenarios where you can maintain or take as input such a reference, or where you are processing the entire list, and here the constant time deletion of linked lists does change the algorithmic complexity.</p>\n\n<p>Of course, if you need to do something like <em>delete the first entry containing the value \"foo\"</em> that implies both a search <em>and</em> a delete operation. Both array-based and linked lists taken <code>O(n)</code> for search, so they don't vary here - but you can meaningfully separate the <em>search</em> and <em>delete</em> operations.</p>\n\n<p>So you could, in principle, pass around <code>Iterator</code> objects rather than list indexes or object values - at least if your use case supports it. However, at the top I said that \"Java has no convenient notion of a pointer to a list node\". Why?</p>\n\n<p>Well because actually using <code>Iterator</code> is actually very inconvenient. First of all, it's tough to get an <code>Iterator</code> to an object in the first place: for example, and unlike C++, the <code>add()</code> methods don't return an Iterator - so to get a pointer to the item you just added, you need to go ahead and iterate over the list or use the <code>listIterator(int index)</code> call, which is inherently inefficient for linked lists. Many methods (e.g., <code>subList()</code>) support only a version that takes indexes, but not Iterators - even when such a method could be efficiently supported.</p>\n\n<p>Add to that the restrictions around iterator invalidation when the list is modified, and they actually become pretty useless for referring to elements except in immutable lists.</p>\n\n<p>So Java's support of pointers to list elements is pretty half-hearted an so it's tough to leverage the constant time operations that linked list offers, except in cases such as adding to the front of a list, or deleting items during iteration.</p>\n\n<p>It's not limited to lists, either - the <code>ConcurrentQueue</code> is also a linked structure which supports constant time deletes, but you can't <a href=\"http://stackoverflow.com/questions/28226759/efficiently-removing-an-element-added-to-a-concurrentqueue\">reliably use that ability from Java</a>. </p>\n", "tags": ["java", "algorithm", "arraylist", "linked-list"], "creation_date": 1476844675, "score": 0, "last_activity_date": 1476844675, "answer_id": 40121165, "is_accepted": false, "owner": {"user_id": 149138, "reputation": 6036, "user_type": "registered", "accept_rate": 67, "display_name": "BeeOnRope", "link": "http://stackoverflow.com/users/149138/beeonrope", "profile_image": "https://www.gravatar.com/avatar/cfd457233c8ebbab383475fc097442d9?s=128&d=identicon&r=PG"}, "title": "Why don&#39;t we count linear search cost as a prerequisite bottleneck for the insertion operation of a linked list, compared to ArrayList?", "question_id": 39838706}