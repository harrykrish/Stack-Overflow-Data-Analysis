{"body": "<p><strong>Note:</strong> I've posted this as a community wiki, we can all add to the list, clarify, etc. <strong>Please no <em>opinions</em>.</strong> Keep it objective.</p>\n\n<hr>\n\n<blockquote>\n  <p>Or is this just a matter of taste/style guide etc?</p>\n</blockquote>\n\n<p>There will be a strong influence of style, yes, but there are some objective observations we can make in terms of the functionality and runtime characteristics of the options that can be used to decide which is appropriate for a given use-case.</p>\n\n<blockquote>\n  <p>Option 1:</p>\n\n<pre><code>function square(n) {\n   return n * n;\n}\n</code></pre>\n</blockquote>\n\n<ul>\n<li>Hoisted (because it's a function declaration).</li>\n<li>Until ES2015 (ES6), only valid at global scope or at the top-level of a function; ES2015+ allows them within control flow statements, but the rules are complex.</li>\n<li>Can be overwritten later via <code>square = ...</code> (or a later function declaration).</li>\n<li>Creates an object and assigns it to <code>square.prototype</code>, even though we don't intend it to be a constructor.</li>\n<li>If at global scope, creates a property on the global object (and thus, a global) because it's a function declaration.</li>\n<li>If <code>this</code> were used within the function, it would be determined by how the function is called, as it's a \"normal\" function.</li>\n</ul>\n\n<blockquote>\n  <p>Option 2:</p>\n\n<pre><code>var square = function(n) {\n  return n * n;\n};\n</code></pre>\n</blockquote>\n\n<ul>\n<li>Not hoisted (because it's an expression), created during control flow.</li>\n<li>Until ES2015, since it's an <em>anonymous</em> function expression, the function didn't have a name. In ES2015+, the name is derived from the variable's name <em>(browser support may lag a bit, it seems to be low on the ES2015 support priority list)</em>.</li>\n<li>Can be overwritten later via <code>square = ...</code></li>\n<li>Creates an object and assigns it to <code>square.prototype</code>, even though we don't intend it to be a constructor.</li>\n<li>Attempts to use it as a constructor (<code>new square</code>) will work, but probably not do what the coder expected.</li>\n<li>If at global scope, creates a property on the global object (and thus, a global) since it's an old-style <code>var</code> variable.</li>\n<li>If <code>this</code> were used within the function, it would be determined by how the function is called, as it's a \"normal\" function.</li>\n</ul>\n\n<blockquote>\n  <p>Option 2.5: <strong>(I've added this one)</strong></p>\n\n<pre><code>var square = function square(n) {\n  return n * n;\n};\n</code></pre>\n</blockquote>\n\n<p>Exactly like Option 2, except that on ES5 and earlier, the function has a true name (<code>square</code>). (Note that the name doesn't have to be the same as the name of the variable, although it is in this example.)</p>\n\n<blockquote>\n  <p>Option 3:</p>\n\n<pre><code>var square = (n) =&gt; {\n   return n * n;\n};\n</code></pre>\n</blockquote>\n\n<p>Could also be written:</p>\n\n<pre><code>var square = n =&gt; n * n;\n</code></pre>\n\n<ul>\n<li>Not hoisted (because it's an expression), created during control flow.</li>\n<li>The function's name is derived from the variable's name <em>(browser support may lag a bit, it seems to be low on the ES2015 support priority list)</em>.</li>\n<li>Can be overwritten later via <code>square = ...</code></li>\n<li><em>Doesn't</em> create an object and assign it to <code>square.prototype</code>.</li>\n<li>Attempts to use it as a constructor (<code>new square</code>) will fail with an informative error (<code>TypeError: square is not a constructor</code>).</li>\n<li>Doesn't have <code>arguments</code> (but you can use rest arguments instead if you need <code>arguments</code> functionality).</li>\n<li>Per spec, requires fewer things to be \"set up\" when calling it, as it doesn't have its own <code>this</code> and doesn't have <code>arguments</code>. But modern JavaScript engines already optimize-out the creation of <code>arguments</code> if you don't use it, and it's unlikely setting up <code>this</code> is a significant cost.</li>\n<li>If at global scope, creates a property on the global object (and thus, a global) since it's an old-style <code>var</code> variable.</li>\n<li>Because it's an arrow function, if <code>this</code> were used within the function, it would use the same <code>this</code> as the code where the function is defined, since arrow functions <em>close over</em> <code>this</code> (rather than having it set by how they're called).</li>\n</ul>\n\n<blockquote>\n  <p>Option 4:</p>\n\n<pre><code>const square = (n) =&gt; {\n   return n * n;\n};\n</code></pre>\n</blockquote>\n\n<p>Could also be written:</p>\n\n<pre><code>const square = n =&gt; n * n;\n</code></pre>\n\n<ul>\n<li>Not hoisted, created during control flow</li>\n<li>The function's name is derived from the variable's name <em>(browser support may lag a bit, it seems to be low on the ES2015 support priority list)</em>.</li>\n<li><em>Can't</em> be overwritten later via <code>square = ...</code></li>\n<li><em>Doesn't</em> create an object and assign it to <code>square.prototype</code>.</li>\n<li>Attempts to use it as a constructor (<code>new square</code>) will fail with an informative error (<code>TypeError: square is not a constructor</code>).</li>\n<li>Doesn't have <code>arguments</code> (see notes on Option 3).</li>\n<li>Per spec, requires fewer things to be \"set up\" when calling it (see notes on Option 3).</li>\n<li>If at global scope, <em>doesn't</em> create a property on the global object (but still creates a global), since it's an ES2015+ <code>const</code>.</li>\n<li>Because it's an arrow function, if <code>this</code> were used within the function, it would use the same <code>this</code> as the code where the function is defined, since arrow functions <em>close over</em> <code>this</code> (rather than having it set by how they're called).</li>\n</ul>\n\n<blockquote>\n  <p>Option 5: <strong>(I've added this one)</strong></p>\n\n<pre><code>let square = (n) =&gt; {\n   return n * n;\n};\n</code></pre>\n</blockquote>\n\n<p>Could also be written:</p>\n\n<pre><code>let square = n =&gt; n * n;\n</code></pre>\n\n<p>Exactly like Option 4, except it can be overwritten later via <code>square = ...</code></p>\n", "last_activity_date": 1469018307, "last_edit_date": 1469018307, "question_id": 38479859, "tags": ["javascript", "ecmascript-6"], "title": "What are the advantages/disadvantages for creating a top level function in ES6 with arrows or without?", "score": 2, "answer_id": 38480257, "creation_date": 1469014666, "is_accepted": true, "owner": {"user_id": 157247, "reputation": 486492, "user_type": "registered", "accept_rate": 89, "display_name": "T.J. Crowder", "link": "http://stackoverflow.com/users/157247/t-j-crowder", "profile_image": "https://www.gravatar.com/avatar/ca3e484c121268e4c8302616b2395eb9?s=128&d=identicon&r=PG"}, "community_owned_date": 1469014666}