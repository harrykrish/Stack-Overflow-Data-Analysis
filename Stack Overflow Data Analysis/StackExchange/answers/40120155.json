{"body": "<p><em>In theory,</em> there exists a data-dependency between the branch instruction and the earlier instruction (the <code>SUB</code> in this case) that modifies the register the branch will examine to jump, but on many modern architectures this dependency does <em>not</em> propagate to the following instructions, due to branch prediction.</p>\n\n<p>That is, on architectures with prediction the data dependency isn't likely to actually cause the branch to <em>take effect</em> after the <code>SUB</code> - usually it will take effect (i.e., jump or not) before the <code>SUB</code> is executed, and only later when the result of the <code>SUB</code> is available will the guess be checked, and all the speculative execution since the branch will be rolled back if the guess was incorrect.</p>\n\n<p>So in a way jumps exist in a grey area when it comes to data dependency on their condition and on their target. In the strictest sense they are dependent, but when prediction is working (and usually it is), they don't behave like that. It's a bit like the grey area that <code>xor r1, r1, r1</code> or <code>foo32bits &gt;&gt; 32</code> exist in: by the strict definition these instructions depend on their inputs, but in these particular case it happens that the answer is always the same (0) and some CPUs may recognize this and not apply the usual dependency rules.</p>\n", "tags": ["assembly", "pipeline", "cpu-architecture"], "creation_date": 1476836895, "score": 2, "last_activity_date": 1476836895, "answer_id": 40120155, "is_accepted": false, "owner": {"user_id": 149138, "reputation": 6036, "user_type": "registered", "accept_rate": 67, "display_name": "BeeOnRope", "link": "http://stackoverflow.com/users/149138/beeonrope", "profile_image": "https://www.gravatar.com/avatar/cfd457233c8ebbab383475fc097442d9?s=128&d=identicon&r=PG"}, "title": "is the branch instruction data dependent?", "question_id": 40116948}