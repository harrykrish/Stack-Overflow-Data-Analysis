{"body": "<p>You go from <code>2</code> to <code>n</code>, adding <code>log log n</code> to the accumulator each step, so you do indeed have <code>n / log log n</code> steps.</p>\n\n<p>However, what is done per step? Each step, you go from <code>j</code> to <code>n</code>, multiplying the accumulator by itself each step. How many operations is that? <strong>I'm not 100% sure</strong>, but based on messing around a bit and on <a href=\"http://stackoverflow.com/a/16472013/15055\">this answer</a>, this seems to end up being <code>log log (n - j)</code> steps, or <code>log log n</code> for short.</p>\n\n<p>So, <code>n / log log n</code> steps, doing <code>log log n</code> operations each step, gives you an <code>O(n / log log n * log log n)</code>, or <code>O(n)</code> algorithm.</p>\n\n<hr>\n\n<p>Some experimentation seems to more or less bear this out (Python), although <code>n_ops</code> appears to flag a bit as <code>n</code> gets bigger:</p>\n\n<pre><code>import math\n\ndef doit(n):\n    n_ops = 0\n\n    j = 2\n    while j &lt; n:\n        k = j\n        while k &lt; n:\n            # sum + = a[k]*b[k]\n            k = k*k\n            n_ops += 1\n\n        k = math.log(n, 2)\n        j += math.log(k, 2)\n        n_ops += 1\n\n    return n_ops\n</code></pre>\n\n<p>Results:</p>\n\n<pre><code>&gt;&gt;&gt; doit(100)\n76\n&gt;&gt;&gt; doit(1000)\n614\n&gt;&gt;&gt; doit(10000)\n5389\n&gt;&gt;&gt; doit(100000)\n49418\n&gt;&gt;&gt; doit(1000000)\n463527\n</code></pre>\n", "tags": ["algorithm", "time-complexity"], "creation_date": 1474321401, "score": 0, "last_activity_date": 1474321401, "answer_id": 39582592, "is_accepted": false, "owner": {"user_id": 15055, "reputation": 94991, "user_type": "registered", "accept_rate": 81, "display_name": "Claudiu", "link": "http://stackoverflow.com/users/15055/claudiu", "profile_image": "https://www.gravatar.com/avatar/7f71287b47b7189d11fe6d3fbc7ed2fe?s=128&d=identicon&r=PG"}, "title": "Determining and analysis the big-O runtimes of these different loops", "question_id": 39582406}