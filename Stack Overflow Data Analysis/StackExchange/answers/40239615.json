{"body": "<p>If you're worried about actual speed, you definitely want to use numpy (as the clever algorithmic tweaks probably have way less effect than the gains to be had from using array operations).  Here are two solutions.  The \"dumb\" solution is slower in most situations but becomes faster as the number of costs increases:</p>\n\n<pre><code>import numpy as np\n\n\ndef is_pareto_efficient_dumb(costs):\n    \"\"\"\n    :param costs: An (n_points, n_costs) array\n    :return: A (n_points, ) boolean array, indicating whether each point is Pareto efficient\n    \"\"\"\n    is_efficient = np.ones(costs.shape[0], dtype = bool)\n    for i, c in enumerate(costs):\n        is_efficient[i] = np.all(np.any(costs&gt;=c, axis=1))\n    return is_efficient\n\n\ndef is_pareto_efficient(costs):\n    \"\"\"\n    :param costs: An (n_points, n_costs) array\n    :return: A (n_points, ) boolean array, indicating whether each point is Pareto efficient\n    \"\"\"\n    is_efficient = np.ones(costs.shape[0], dtype = bool)\n    for i, c in enumerate(costs):\n        if is_efficient[i]:\n            is_efficient[is_efficient] = np.any(costs[is_efficient]&lt;=c, axis=1)  # Remove dominated points\n    return is_efficient\n</code></pre>\n\n<p>Profiling tests:</p>\n\n<p>With 10000 samples, 2 costs:</p>\n\n<pre><code>dumb: Elapsed time is 0.9168s\nsmart: Elapsed time is 0.004274s\n</code></pre>\n\n<p>With 5000 samples, 15 costs:</p>\n\n<pre><code>dumb: Elapsed time is 1.394s\nsmart: Elapsed time is 1.982s\n</code></pre>\n", "tags": ["python", "numpy"], "creation_date": 1477397437, "score": 0, "last_activity_date": 1477397437, "answer_id": 40239615, "is_accepted": false, "owner": {"user_id": 851699, "reputation": 1649, "user_type": "registered", "accept_rate": 36, "display_name": "Peter", "link": "http://stackoverflow.com/users/851699/peter", "profile_image": "https://i.stack.imgur.com/jDiPy.png?s=128&g=1"}, "title": "Fast calculation of Pareto front in Python", "question_id": 32791911}