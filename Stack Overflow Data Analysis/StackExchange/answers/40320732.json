{"body": "<p>Ok I finally managed to implement this. There are a few steps involved.</p>\n\n<p><strong>First, import and tweak the overlapping marker spidifier script</strong></p>\n\n<p>Create a file within your project with the modified OMS script, bound below.</p>\n\n<p>If you want to build the project manually, do the following:</p>\n\n<ul>\n<li>git clone <a href=\"https://github.com/jawj/OverlappingMarkerSpiderfier.git\" rel=\"nofollow\">https://github.com/jawj/OverlappingMarkerSpiderfier.git</a></li>\n<li>cd OverlappingMarkerSpiderfier</li>\n<li>Open bower.json and change the url for devDependency closure-compiler to <code>//dl.google.com/closure-compiler/compiler-20131014.zip</code></li>\n<li>run <code>npm run dist</code></li>\n<li>open lib/oms.js and modify the file to export the function as shown in the code below:</li>\n</ul>\n\n<p>```\n    /** @preserve OverlappingMarkerSpiderfier\n    <a href=\"https://github.com/jawj/OverlappingMarkerSpiderfier\" rel=\"nofollow\">https://github.com/jawj/OverlappingMarkerSpiderfier</a>\n    Copyright (c) 2011 - 2013 George MacKerron\n    Released under the MIT licence: <a href=\"http://opensource.org/licenses/mit-license\" rel=\"nofollow\">http://opensource.org/licenses/mit-license</a>\n    Note: The Google Maps API v3 must be included <em>before</em> this code\n     */</p>\n\n<pre><code>module.exports = function () {\n\n  var __hasProp = {}.hasOwnProperty, __slice = [].slice;\n  var ge, gm, lcH, lcU, mt, p, twoPi, x, _i, _len, _ref;\n\n  p = _Class.prototype;\n\n  _ref = [_Class, p];\n  for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {\n    x = _ref[_i];\n    x['VERSION'] = '0.3.3';\n  }\n\n  gm = google.maps;\n\n  ge = gm.event;\n\n  mt = gm.MapTypeId;\n\n  twoPi = Math.PI * 2;\n\n  p['keepSpiderfied'] = false;\n\n  p['markersWontHide'] = false;\n\n  p['markersWontMove'] = false;\n\n  p['nearbyDistance'] = 20;\n\n  p['circleSpiralSwitchover'] = 9;\n\n  p['circleFootSeparation'] = 23;\n\n  p['circleStartAngle'] = twoPi / 12;\n\n  p['spiralFootSeparation'] = 26;\n\n  p['spiralLengthStart'] = 11;\n\n  p['spiralLengthFactor'] = 4;\n\n  p['spiderfiedZIndex'] = 1000;\n\n  p['usualLegZIndex'] = 10;\n\n  p['highlightedLegZIndex'] = 20;\n\n  p['event'] = 'click';\n\n  p['minZoomLevel'] = false;\n\n  p['legWeight'] = 1.5;\n\n  p['legColors'] = {\n    'usual': {},\n    'highlighted': {}\n  };\n\n  lcU = p['legColors']['usual'];\n\n  lcH = p['legColors']['highlighted'];\n\n  lcU[mt.HYBRID] = lcU[mt.SATELLITE] = '#fff';\n\n  lcH[mt.HYBRID] = lcH[mt.SATELLITE] = '#f00';\n\n  lcU[mt.TERRAIN] = lcU[mt.ROADMAP] = '#444';\n\n  lcH[mt.TERRAIN] = lcH[mt.ROADMAP] = '#f00';\n\n  function _Class(map, opts) {\n    var e, k, v, _j, _len1, _ref1;\n    this.map = map;\n    if (opts == null) {\n      opts = {};\n    }\n    for (k in opts) {\n      if (!__hasProp.call(opts, k)) continue;\n      v = opts[k];\n      this[k] = v;\n    }\n    this.projHelper = new this.constructor.ProjHelper(this.map);\n    this.initMarkerArrays();\n    this.listeners = {};\n    _ref1 = ['click', 'zoom_changed', 'maptypeid_changed'];\n    for (_j = 0, _len1 = _ref1.length; _j &lt; _len1; _j++) {\n      e = _ref1[_j];\n      ge.addListener(this.map, e, (function(_this) {\n        return function() {\n          return _this['unspiderfy']();\n        };\n      })(this));\n    }\n    return this;\n  }\n\n  p.initMarkerArrays = function() {\n    this.markers = [];\n    return this.markerListenerRefs = [];\n  };\n\n  p['addMarker'] = function(marker) {\n    var listenerRefs;\n    if (marker['_oms'] != null) {\n      return this;\n    }\n    marker['_oms'] = true;\n    listenerRefs = [\n      ge.addListener(marker, this['event'], (function(_this) {\n        return function(event) {\n          return _this.spiderListener(marker, event);\n        };\n      })(this))\n    ];\n    if (!this['markersWontHide']) {\n      listenerRefs.push(ge.addListener(marker, 'visible_changed', (function(_this) {\n        return function() {\n          return _this.markerChangeListener(marker, false);\n        };\n      })(this)));\n    }\n    if (!this['markersWontMove']) {\n      listenerRefs.push(ge.addListener(marker, 'position_changed', (function(_this) {\n        return function() {\n          return _this.markerChangeListener(marker, true);\n        };\n      })(this)));\n    }\n    this.markerListenerRefs.push(listenerRefs);\n    this.markers.push(marker);\n    return this;\n  };\n\n  p.markerChangeListener = function(marker, positionChanged) {\n    if ((marker['_omsData'] != null) &amp;&amp; (positionChanged || !marker.getVisible()) &amp;&amp; !((this.spiderfying != null) || (this.unspiderfying != null))) {\n      return this['unspiderfy'](positionChanged ? marker : null);\n    }\n  };\n\n  p['getMarkers'] = function() {\n    return this.markers.slice(0);\n  };\n\n  p['removeMarker'] = function(marker) {\n    var i, listenerRef, listenerRefs, _j, _len1;\n    if (marker['_omsData'] != null) {\n      this['unspiderfy']();\n    }\n    i = this.arrIndexOf(this.markers, marker);\n    if (i &lt; 0) {\n      return this;\n    }\n    listenerRefs = this.markerListenerRefs.splice(i, 1)[0];\n    for (_j = 0, _len1 = listenerRefs.length; _j &lt; _len1; _j++) {\n      listenerRef = listenerRefs[_j];\n      ge.removeListener(listenerRef);\n    }\n    delete marker['_oms'];\n    this.markers.splice(i, 1);\n    return this;\n  };\n\n  p['clearMarkers'] = function() {\n    var i, listenerRef, listenerRefs, marker, _j, _k, _len1, _len2, _ref1;\n    this['unspiderfy']();\n    _ref1 = this.markers;\n    for (i = _j = 0, _len1 = _ref1.length; _j &lt; _len1; i = ++_j) {\n      marker = _ref1[i];\n      listenerRefs = this.markerListenerRefs[i];\n      for (_k = 0, _len2 = listenerRefs.length; _k &lt; _len2; _k++) {\n        listenerRef = listenerRefs[_k];\n        ge.removeListener(listenerRef);\n      }\n      delete marker['_oms'];\n    }\n    this.initMarkerArrays();\n    return this;\n  };\n\n  p['addListener'] = function(event, func) {\n    var _base;\n    ((_base = this.listeners)[event] != null ? _base[event] : _base[event] = []).push(func);\n    return this;\n  };\n\n  p['removeListener'] = function(event, func) {\n    var i;\n    i = this.arrIndexOf(this.listeners[event], func);\n    if (!(i &lt; 0)) {\n      this.listeners[event].splice(i, 1);\n    }\n    return this;\n  };\n\n  p['clearListeners'] = function(event) {\n    this.listeners[event] = [];\n    return this;\n  };\n\n  p.trigger = function() {\n    var args, event, func, _j, _len1, _ref1, _ref2, _results;\n    event = arguments[0], args = 2 &lt;= arguments.length ? __slice.call(arguments, 1) : [];\n    _ref2 = (_ref1 = this.listeners[event]) != null ? _ref1 : [];\n    _results = [];\n    for (_j = 0, _len1 = _ref2.length; _j &lt; _len1; _j++) {\n      func = _ref2[_j];\n      _results.push(func.apply(null, args));\n    }\n    return _results;\n  };\n\n  p.generatePtsCircle = function(count, centerPt) {\n    var angle, angleStep, circumference, i, legLength, _j, _results;\n    circumference = this['circleFootSeparation'] * (2 + count);\n    legLength = circumference / twoPi;\n    angleStep = twoPi / count;\n    _results = [];\n    for (i = _j = 0; 0 &lt;= count ? _j &lt; count : _j &gt; count; i = 0 &lt;= count ? ++_j : --_j) {\n      angle = this['circleStartAngle'] + i * angleStep;\n      _results.push(new gm.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle)));\n    }\n    return _results;\n  };\n\n  p.generatePtsSpiral = function(count, centerPt) {\n    var angle, i, legLength, pt, _j, _results;\n    legLength = this['spiralLengthStart'];\n    angle = 0;\n    _results = [];\n    for (i = _j = 0; 0 &lt;= count ? _j &lt; count : _j &gt; count; i = 0 &lt;= count ? ++_j : --_j) {\n      angle += this['spiralFootSeparation'] / legLength + i * 0.0005;\n      pt = new gm.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle));\n      legLength += twoPi * this['spiralLengthFactor'] / angle;\n      _results.push(pt);\n    }\n    return _results;\n  };\n\n  p.spiderListener = function(marker, event) {\n    var $this, clear, m, mPt, markerPt, markerSpiderfied, nDist, nearbyMarkerData, nonNearbyMarkers, pxSq, _j, _len1, _ref1;\n    markerSpiderfied = marker['_omsData'] != null;\n    if (!(markerSpiderfied &amp;&amp; this['keepSpiderfied'])) {\n      if (this['event'] === 'mouseover') {\n        $this = this;\n        clear = function() {\n          return $this['unspiderfy']();\n        };\n        window.clearTimeout(p.timeout);\n        p.timeout = setTimeout(clear, 3000);\n      } else {\n        this['unspiderfy']();\n      }\n    }\n    if (markerSpiderfied || this.map.getStreetView().getVisible() || this.map.getMapTypeId() === 'GoogleEarthAPI') {\n      return this.trigger('click', marker, event);\n    } else {\n      nearbyMarkerData = [];\n      nonNearbyMarkers = [];\n      nDist = this['nearbyDistance'];\n      pxSq = nDist * nDist;\n      markerPt = this.llToPt(marker.position);\n      _ref1 = this.markers;\n      for (_j = 0, _len1 = _ref1.length; _j &lt; _len1; _j++) {\n        m = _ref1[_j];\n        if (!((m.map != null) &amp;&amp; m.getVisible())) {\n          continue;\n        }\n        mPt = this.llToPt(m.position);\n        if (this.ptDistanceSq(mPt, markerPt) &lt; pxSq) {\n          nearbyMarkerData.push({\n            marker: m,\n            markerPt: mPt\n          });\n        } else {\n          nonNearbyMarkers.push(m);\n        }\n      }\n      if (nearbyMarkerData.length === 1) {\n        return this.trigger('click', marker, event);\n      } else {\n        return this.spiderfy(nearbyMarkerData, nonNearbyMarkers);\n      }\n    }\n  };\n\n  p['markersNearMarker'] = function(marker, firstOnly) {\n    var m, mPt, markerPt, markers, nDist, pxSq, _j, _len1, _ref1, _ref2, _ref3;\n    if (firstOnly == null) {\n      firstOnly = false;\n    }\n    if (this.projHelper.getProjection() == null) {\n      throw \"Must wait for 'idle' event on map before calling markersNearMarker\";\n    }\n    nDist = this['nearbyDistance'];\n    pxSq = nDist * nDist;\n    markerPt = this.llToPt(marker.position);\n    markers = [];\n    _ref1 = this.markers;\n    for (_j = 0, _len1 = _ref1.length; _j &lt; _len1; _j++) {\n      m = _ref1[_j];\n      if (m === marker || (m.map == null) || !m.getVisible()) {\n        continue;\n      }\n      mPt = this.llToPt((_ref2 = (_ref3 = m['_omsData']) != null ? _ref3.usualPosition : void 0) != null ? _ref2 : m.position);\n      if (this.ptDistanceSq(mPt, markerPt) &lt; pxSq) {\n        markers.push(m);\n        if (firstOnly) {\n          break;\n        }\n      }\n    }\n    return markers;\n  };\n\n  p['markersNearAnyOtherMarker'] = function() {\n    var i, i1, i2, m, m1, m1Data, m2, m2Data, mData, nDist, pxSq, _j, _k, _l, _len1, _len2, _len3, _ref1, _ref2, _ref3, _results;\n    if (this.projHelper.getProjection() == null) {\n      throw \"Must wait for 'idle' event on map before calling markersNearAnyOtherMarker\";\n    }\n    nDist = this['nearbyDistance'];\n    pxSq = nDist * nDist;\n    mData = (function() {\n      var _j, _len1, _ref1, _ref2, _ref3, _results;\n      _ref1 = this.markers;\n      _results = [];\n      for (_j = 0, _len1 = _ref1.length; _j &lt; _len1; _j++) {\n        m = _ref1[_j];\n        _results.push({\n          pt: this.llToPt((_ref2 = (_ref3 = m['_omsData']) != null ? _ref3.usualPosition : void 0) != null ? _ref2 : m.position),\n          willSpiderfy: false\n        });\n      }\n      return _results;\n    }).call(this);\n    _ref1 = this.markers;\n    for (i1 = _j = 0, _len1 = _ref1.length; _j &lt; _len1; i1 = ++_j) {\n      m1 = _ref1[i1];\n      if (!((m1.map != null) &amp;&amp; m1.getVisible())) {\n        continue;\n      }\n      m1Data = mData[i1];\n      if (m1Data.willSpiderfy) {\n        continue;\n      }\n      _ref2 = this.markers;\n      for (i2 = _k = 0, _len2 = _ref2.length; _k &lt; _len2; i2 = ++_k) {\n        m2 = _ref2[i2];\n        if (i2 === i1) {\n          continue;\n        }\n        if (!((m2.map != null) &amp;&amp; m2.getVisible())) {\n          continue;\n        }\n        m2Data = mData[i2];\n        if (i2 &lt; i1 &amp;&amp; !m2Data.willSpiderfy) {\n          continue;\n        }\n        if (this.ptDistanceSq(m1Data.pt, m2Data.pt) &lt; pxSq) {\n          m1Data.willSpiderfy = m2Data.willSpiderfy = true;\n          break;\n        }\n      }\n    }\n    _ref3 = this.markers;\n    _results = [];\n    for (i = _l = 0, _len3 = _ref3.length; _l &lt; _len3; i = ++_l) {\n      m = _ref3[i];\n      if (mData[i].willSpiderfy) {\n        _results.push(m);\n      }\n    }\n    return _results;\n  };\n\n  p.makeHighlightListenerFuncs = function(marker) {\n    return {\n      highlight: (function(_this) {\n        return function() {\n          return marker['_omsData'].leg.setOptions({\n            strokeColor: _this['legColors']['highlighted'][_this.map.mapTypeId],\n            zIndex: _this['highlightedLegZIndex']\n          });\n        };\n      })(this),\n      unhighlight: (function(_this) {\n        return function() {\n          return marker['_omsData'].leg.setOptions({\n            strokeColor: _this['legColors']['usual'][_this.map.mapTypeId],\n            zIndex: _this['usualLegZIndex']\n          });\n        };\n      })(this)\n    };\n  };\n\n  p.spiderfy = function(markerData, nonNearbyMarkers) {\n    var bodyPt, footLl, footPt, footPts, highlightListenerFuncs, leg, marker, md, nearestMarkerDatum, numFeet, spiderfiedMarkers;\n    if (this['minZoomLevel'] &amp;&amp; this.map.getZoom() &lt; this['minZoomLevel']) {\n      return false;\n    }\n    this.spiderfying = true;\n    numFeet = markerData.length;\n    bodyPt = this.ptAverage((function() {\n      var _j, _len1, _results;\n      _results = [];\n      for (_j = 0, _len1 = markerData.length; _j &lt; _len1; _j++) {\n        md = markerData[_j];\n        _results.push(md.markerPt);\n      }\n      return _results;\n    })());\n    footPts = numFeet &gt;= this['circleSpiralSwitchover'] ? this.generatePtsSpiral(numFeet, bodyPt).reverse() : this.generatePtsCircle(numFeet, bodyPt);\n    spiderfiedMarkers = (function() {\n      var _j, _len1, _results;\n      _results = [];\n      for (_j = 0, _len1 = footPts.length; _j &lt; _len1; _j++) {\n        footPt = footPts[_j];\n        footLl = this.ptToLl(footPt);\n        nearestMarkerDatum = this.minExtract(markerData, (function(_this) {\n          return function(md) {\n            return _this.ptDistanceSq(md.markerPt, footPt);\n          };\n        })(this));\n        marker = nearestMarkerDatum.marker;\n        leg = new gm.Polyline({\n          map: this.map,\n          path: [marker.position, footLl],\n          strokeColor: this['legColors']['usual'][this.map.mapTypeId],\n          strokeWeight: this['legWeight'],\n          zIndex: this['usualLegZIndex']\n        });\n        marker['_omsData'] = {\n          usualPosition: marker.position,\n          leg: leg\n        };\n        if (this['legColors']['highlighted'][this.map.mapTypeId] !== this['legColors']['usual'][this.map.mapTypeId]) {\n          highlightListenerFuncs = this.makeHighlightListenerFuncs(marker);\n          marker['_omsData'].hightlightListeners = {\n            highlight: ge.addListener(marker, 'mouseover', highlightListenerFuncs.highlight),\n            unhighlight: ge.addListener(marker, 'mouseout', highlightListenerFuncs.unhighlight)\n          };\n        }\n        marker.setPosition(footLl);\n        marker.setZIndex(Math.round(this['spiderfiedZIndex'] + footPt.y));\n        _results.push(marker);\n      }\n      return _results;\n    }).call(this);\n    delete this.spiderfying;\n    this.spiderfied = true;\n    return this.trigger('spiderfy', spiderfiedMarkers, nonNearbyMarkers);\n  };\n\n  p['unspiderfy'] = function(markerNotToMove) {\n    var listeners, marker, nonNearbyMarkers, unspiderfiedMarkers, _j, _len1, _ref1;\n    if (markerNotToMove == null) {\n      markerNotToMove = null;\n    }\n    if (this.spiderfied == null) {\n      return this;\n    }\n    this.unspiderfying = true;\n    unspiderfiedMarkers = [];\n    nonNearbyMarkers = [];\n    _ref1 = this.markers;\n    for (_j = 0, _len1 = _ref1.length; _j &lt; _len1; _j++) {\n      marker = _ref1[_j];\n      if (marker['_omsData'] != null) {\n        marker['_omsData'].leg.setMap(null);\n        if (marker !== markerNotToMove) {\n          marker.setPosition(marker['_omsData'].usualPosition);\n        }\n        marker.setZIndex(null);\n        listeners = marker['_omsData'].hightlightListeners;\n        if (listeners != null) {\n          ge.removeListener(listeners.highlight);\n          ge.removeListener(listeners.unhighlight);\n        }\n        delete marker['_omsData'];\n        unspiderfiedMarkers.push(marker);\n      } else {\n        nonNearbyMarkers.push(marker);\n      }\n    }\n    delete this.unspiderfying;\n    delete this.spiderfied;\n    this.trigger('unspiderfy', unspiderfiedMarkers, nonNearbyMarkers);\n    return this;\n  };\n\n  p.ptDistanceSq = function(pt1, pt2) {\n    var dx, dy;\n    dx = pt1.x - pt2.x;\n    dy = pt1.y - pt2.y;\n    return dx * dx + dy * dy;\n  };\n\n  p.ptAverage = function(pts) {\n    var numPts, pt, sumX, sumY, _j, _len1;\n    sumX = sumY = 0;\n    for (_j = 0, _len1 = pts.length; _j &lt; _len1; _j++) {\n      pt = pts[_j];\n      sumX += pt.x;\n      sumY += pt.y;\n    }\n    numPts = pts.length;\n    return new gm.Point(sumX / numPts, sumY / numPts);\n  };\n\n  p.llToPt = function(ll) {\n    return this.projHelper.getProjection().fromLatLngToDivPixel(ll);\n  };\n\n  p.ptToLl = function(pt) {\n    return this.projHelper.getProjection().fromDivPixelToLatLng(pt);\n  };\n\n  p.minExtract = function(set, func) {\n    var bestIndex, bestVal, index, item, val, _j, _len1;\n    for (index = _j = 0, _len1 = set.length; _j &lt; _len1; index = ++_j) {\n      item = set[index];\n      val = func(item);\n      if ((typeof bestIndex === \"undefined\" || bestIndex === null) || val &lt; bestVal) {\n        bestVal = val;\n        bestIndex = index;\n      }\n    }\n    return set.splice(bestIndex, 1)[0];\n  };\n\n  p.arrIndexOf = function(arr, obj) {\n    var i, o, _j, _len1;\n    if (arr.indexOf != null) {\n      return arr.indexOf(obj);\n    }\n    for (i = _j = 0, _len1 = arr.length; _j &lt; _len1; i = ++_j) {\n      o = arr[i];\n      if (o === obj) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\n  _Class.ProjHelper = function(map) {\n    return this.setMap(map);\n  };\n\n  _Class.ProjHelper.prototype = new gm.OverlayView();\n\n  _Class.ProjHelper.prototype['draw'] = function() {};\n\n  return _Class;\n\n};\n</code></pre>\n\n<p>```</p>\n\n<p><strong>Import the OMS script into your component that uses sebm-google-map</strong></p>\n\n<p>Add the following property to your component that uses the sebm-google-map component:</p>\n\n<p><code>let oms = require('../../scripts/overlapping-marker-spidifier.js');</code></p>\n\n<p><strong>Get the native map, marker manager and markers</strong></p>\n\n<p>Create a new directive that will be used to get the native map object, the marker manager, and the markers. It will be nested inside the sebm-google-map component like so (notice get-google-map directive, and make sure your markers are nested within the get-google-map directive):</p>\n\n<pre><code>&lt;my-parent-component&gt;\n    &lt;sebm-google-map&gt;\n        &lt;get-google-map (map)=\"setMap($event)\" (markerManager)=\"setMarkerManager($event)\" (markers)=\"setMarkers($event)\"&gt;\n            &lt;sebm-google-map-marker ... &gt;&lt;/sebm-google-map-marker&gt;\n        &lt;/get-google-map&gt;\n    &lt;/sebm-google-map&gt;\n&lt;/my-parent-component&gt;\n</code></pre>\n\n<p>Here's the code for the directive:</p>\n\n<pre><code>import { Directive, Output, EventEmitter, AfterViewInit, ContentChildren, QueryList } from '@angular/core';\nimport { GoogleMapsAPIWrapper, MarkerManager, SebmGoogleMapMarker } from 'angular2-google-maps/core';\n\n@Directive({\n  selector: 'get-google-map',\n})\nexport class GetGoogleMapDirective implements AfterViewInit {\n\n  /**\n   * Get native map object\n   */\n  private _map: any = null;\n  @Output('map') mapChanged: EventEmitter&lt;any&gt; = new EventEmitter&lt;any&gt;();\n  set map(val){\n    this._map = val;\n    this.mapChanged.emit(val);\n  }\n  get map(){\n    return this._map;\n  }\n\n  /**\n   * Get marker manager\n   */\n  private _markerManager: any = null;\n  @Output('markerManager') markerManagerChanged: EventEmitter&lt;MarkerManager&gt; = new EventEmitter&lt;MarkerManager&gt;();\n  set markerManager(val){\n    this._markerManager = val;\n    this.markerManagerChanged.emit(val);\n  }\n  get markerManager(){\n    return this._markerManager;\n  }\n\n  /**\n   * Get sebm markers\n   */\n  private _markers: any = null;\n  @Output('markers') markersChanged: EventEmitter&lt;SebmGoogleMapMarker[]&gt; = new EventEmitter&lt;SebmGoogleMapMarker[]&gt;();\n  set markers(val){\n    this._markers = val;\n    this.markersChanged.emit(val);\n  }\n  get markers(){\n    return this._markers;\n  }\n  @ContentChildren(SebmGoogleMapMarker) markerChildren: QueryList&lt;SebmGoogleMapMarker&gt;;\n\n  constructor(\n    private googleMapsWrapper: GoogleMapsAPIWrapper,\n    private googleMarkerManager: MarkerManager\n  ) { }\n\n  ngAfterViewInit() {\n    // get native map\n    this.googleMapsWrapper.getNativeMap().then(map =&gt; {\n      this.map = map;\n    }, error =&gt; {\n      throw error;\n    })\n\n    // get marker manager\n    this.markerManager = this.googleMarkerManager;\n\n    // get markers\n    this.markerChildren.changes.subscribe(markers =&gt; {\n      this.markers = markers._results;\n    })\n  }\n}\n</code></pre>\n\n<p>Three things happen when this directive is inited:</p>\n\n<ul>\n<li>It gets a reference to the native map object and outputs it using an event emitter</li>\n<li>It gets a reference to the marker manager and outputs it using an event emitter</li>\n<li>It gets references to all SebmGoogleMapMarkers</li>\n</ul>\n\n<p><strong>Make use of the marker manager, markers, and native map object in your parent component</strong></p>\n\n<p>Notice the event bindings on the get-google-map outputs for the markerManager, map and markers. We need to set up functions for these in our parent object to catch these objects when they are outputted:</p>\n\n<pre><code>  /**\n   * Sets up google map spidifier\n   */\n  setupSpidifier(){\n    let getOms = oms();\n    this.overlappingMarkerSpidifier = getOms.call(getOms.prototype, this.map); \n  }\n\n  /**\n   * Sets a reference to the google map object created by sebm - uses GetGoogleMapComponent\n   */\n  setMap(map: any){\n    this.map = map;\n    this.setupSpidifier();\n  }\n\n  /**\n   * Gets the google marker manager from get-google-map\n   */\n  setMarkerManager(markerManager: MarkerManager){\n    this.markerManager = markerManager;\n  }\n\n  /**\n   * Sets the markers, used by spidifier\n   */\n  setMarkers(markers: SebmGoogleMapMarker[]){\n    this.markers = markers;\n    for(let marker of markers){\n      this.markerManager.getNativeMarker(marker).then(marker =&gt; {\n        this.overlappingMarkerSpidifier.addMarker(marker);\n      });\n    }\n  }\n</code></pre>\n\n<p>The above code catches the map, marker manager and markers being outputted from our directive. When we get the map, we save it, then call setup spidifier, which initializes the OMS on our sebm-map. </p>\n\n<p>Next, we cache the marker manager, and each time the markers are outputted we add them to the OMS. </p>\n\n<hr>\n\n<p>That's it! Apologise if the answer is unclear, wrote it in quite a rush so just comment if I need to clarify anything.</p>\n", "tags": ["google-maps", "angular2", "typescript", "webpack"], "creation_date": 1477755329, "score": 0, "last_activity_date": 1477755329, "answer_id": 40320732, "is_accepted": false, "owner": {"user_id": 939543, "reputation": 480, "user_type": "registered", "accept_rate": 79, "display_name": "Max Mumford", "link": "http://stackoverflow.com/users/939543/max-mumford", "profile_image": "https://www.gravatar.com/avatar/ee55387d609c7277ad57ac164e4a05cd?s=128&d=identicon&r=PG"}, "title": "Implementing OverlappingMarkerSpidifier with sebm-angular2-google-map", "question_id": 40294080}