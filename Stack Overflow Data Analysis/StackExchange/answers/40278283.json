{"title": "Libav (ffmpeg) copying decoded video timestamps to encoder", "tags": ["c++", "ffmpeg", "video-encoding", "libav"], "creation_date": 1477551976, "score": 3, "body": "<p>I think your issue here is with time bases which are at first a bit confusing.</p>\n\n<ul>\n<li><code>d.stream-&gt;time_base: Input video stream time base</code>. This is a resolution of timestamps in the input container. Encoded frame returned from <code>av_read_frame</code> will have its timestamps in this resolution.</li>\n<li><code>d.stream-&gt;codec-&gt;time_base: Not sure what this is</code>. It is old API left here for API compatibility; you are using codec parameters so ignore it.</li>\n<li><code>d.codecx-&gt;time_base: Input codec context time-base. For my test input file this is 0/1. Am I supposed to set it?</code> This is a resolution of timestamps for the codec (as opposed to container). Codec will assume its input encoded frame have its timestamps in this resolution, and also it will set timestamps in output decoded frame in this resolution.</li>\n<li><code>e.stream-&gt;time_base: Time base of the output stream I create</code>. Same as with decoder</li>\n<li><code>e.stream-&gt;codec-&gt;time_base</code>. Same as with demuxer - ignore this one.</li>\n<li><code>e.codecx-&gt;time_base</code> - same as with demuxer</li>\n</ul>\n\n<p>So you need to do following:</p>\n\n<ul>\n<li>open demuxer. That part works</li>\n<li>set decoder timebase to some \"sane\" value because decoder might not do that, and <strong>0/1 is bad</strong>. Things won't work as they should if any of timebases for any of components are not set. Easiest is to just copy time base from demuxer</li>\n<li>open decoder. It might change its timebase, or it might not.</li>\n<li>set encoder timebase. Easiest is to copy timebase from (now opened) decoder since you are not changing framerates or anything.</li>\n<li>open encoder. It might change its timebase</li>\n<li>set muxer timebase. Again, easiest is to copy timebase from encoder</li>\n<li>open muxer. It might change its timebase as well.</li>\n</ul>\n\n<p>Now for each frame:</p>\n\n<ul>\n<li>read it from the demuxer</li>\n<li>convert timestamps from demuxer to decoder timebases. There is <code>av_packet_rescale_ts</code> to help you do that</li>\n<li>decode packet</li>\n<li>set frame timestamp (<code>pts</code>) to a value returned by <code>av_frame_get_best_effort_timestamp</code> </li>\n<li>convert frame timestamp from decoder to encoder timebases. Use <code>av_rescale_q</code> or <code>av_rescale_q_rnd</code></li>\n<li>encode packet</li>\n<li>convert timestamps from encoder to muxer timebases. Again, use <code>av_packet_rescale_ts</code></li>\n</ul>\n\n<p>This might be an overkill, in particular maybe encoders doesn't change their timebase on open (in which case you don't need to convert raw frames' <code>pts</code>).</p>\n\n<hr>\n\n<p>Regarding flushing - frames you pass to encoder are not necessarily encoded and output right away, so yes you are supposed to call <code>avcodec_encode_video2</code> with NULL as a frame to let the encoder know you are done and make it output all the remaining data (which you need to pass through muxer as with all the other packets). In fact, you are supposed to do so repeatedly until it stops spewing out packets. See one of encoding examples in <code>doc/examples</code> folder inside ffmpeg for some samples.</p>\n", "last_activity_date": 1477630140, "answer_id": 40278283, "is_accepted": true, "owner": {"user_id": 6909048, "reputation": 410, "user_type": "registered", "display_name": "Andrey Turkin", "link": "http://stackoverflow.com/users/6909048/andrey-turkin", "profile_image": "https://www.gravatar.com/avatar/af2db37ccd50ab0fb72ce3532577b50b?s=128&d=identicon&r=PG"}, "last_edit_date": 1477630140, "question_id": 40275242}