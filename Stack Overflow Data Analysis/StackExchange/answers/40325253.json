{"title": "Utilize memory past the end of a std::vector using a custom overallocating allocator", "tags": ["c++", "language-lawyer", "stdvector", "allocator"], "creation_date": 1477790938, "score": 1, "body": "<p>Stepping back a moment, if the problem you are trying to solve is to allow the underlying memory to be processed effectively by SIMD intrinsics or unrolled loops, or both, you don't necessarily need to allocate memory beyond the used amount just to \"round off\" the allocation size to a multiple of vector width.</p>\n\n<p>There are various approaches used to handle this situation, and you mentioned a couple, such as special lead-in and lead-out code to handle the leading and trailing portions. There are actually two distinct problems here - handling the fact the data isn't a multiple of the vector width, and handling (possibly) unaligned starting addresses. Your over-allocation method is tackling the first issue - but there's probably a better way...</p>\n\n<p>Most SIMD code in practice can simply <em>read beyond</em> the end of the processed region. Some might argue that this is technically <em>UB</em> - but when using SIMD intrinsics you are already venturing beyond the walls of Standard C++. In fact, this technique is <a href=\"http://stackoverflow.com/a/37801845/149138\">already widely used</a> in the standard library and so it is implicitly endorsed by compiler and library maintainers. It is also a standard method for handling SIMD codes in general, so you can be pretty sure it's not going to suddenly break.</p>\n\n<p>They key to making it work is the observation that if you can validly read even a single byte at some location <code>N</code>, then any a <em>naturally aligned</em> read of any size<sup>1</sup> won't trigger a fault. Of course, you still need to ignore or otherwise handle the data you read beyond the end of the officially allocated area - but you'll need to do that anyway with your \"allocate extra\" approach, right? Depending on the algorithm, you may mask away the invalid data, or exclude invalid data after the SIMD portion is done (i.e., if you are searching for a byte, if you find a byte after the allocated area, it's the same as \"not found\").</p>\n\n<p>To make this work, you need to be reading in an aligned fashion, but that's probably something you already want to do I think. You can either arrange to have your memory allocated aligned in the first place, or do an overlapping read at the start (i.e., one unaligned read first, then all aligned with the first aligned read overlapping the unaligned portion), or use the same trick as the tail to <em>read before</em> the array (with the same reasoning as to why this is safe). Furthermore, there are various tricks to request aligned memory without needing to write your own allocator.</p>\n\n<p>Overall, my recommendation is to try to <em>avoid</em> writing a custom allocator. Unless the code is fairly tightly contained, you may run into various pitfalls, including other code making wrong assumptions about how your memory was allocated and the various other pitfalls Leon mentions in his answer. Furthermore, using a custom allocator disables a bunch of optimizations used by the standard container algorithms, unless you use it everywhere, since many of them apply only to containers using the same allocator.</p>\n\n<p>Furthermore, when I was actually implementing custom allocators<sup>2</sup> , I found that it was a nice idea in theory, but a bit too obscure to be well-supported in an identical fashion across all the compilers. Now the compilers have become a lot more compliant over time (I'm looking mostly at you, Visual Studio), and template support has also improved, so perhaps that's not an issue, but I feel it still falls into the category of \"do it only if you must\".</p>\n\n<p>Keep in mind also that custom allocators don't compose well - you only get the one! If someone else on your project wants to use a custom allocator for your container for some other reason, they won't be able to do it (although you could coordinate and create a combined allocator).</p>\n\n<p>This <a href=\"http://stackoverflow.com/q/37800739/149138\">question</a> I asked earlier - also motivated by SIMD - covers a lot of the ground about the safety of reading past the end (and, implicitly, before the beginning), and is probably a good place to start if you are considering this.</p>\n\n<hr>\n\n<p><sup>1</sup> Technically, the restriction is any aligned read up to the page size, which at 4K or larger is plenty for any of the current vector-oriented general purpose ISAs.</p>\n\n<p><sup>2</sup> In this case, I was doing it not for SIMD, but basically to avoid <code>malloc()</code> and to allow partially on-stack and contiguous fast allocations for containers with many small nodes.</p>\n", "last_activity_date": 1477791524, "answer_id": 40325253, "is_accepted": false, "owner": {"user_id": 149138, "reputation": 6036, "user_type": "registered", "accept_rate": 67, "display_name": "BeeOnRope", "link": "http://stackoverflow.com/users/149138/beeonrope", "profile_image": "https://www.gravatar.com/avatar/cfd457233c8ebbab383475fc097442d9?s=128&d=identicon&r=PG"}, "last_edit_date": 1477791524, "question_id": 40054362}