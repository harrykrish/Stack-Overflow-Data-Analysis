{"body": "<p>No, <code>varA</code> is not a compile time constant - it can certainly be different every time the function is called. Constants have a specific definition in the standard - some of the key details are touched on in <a href=\"http://stackoverflow.com/a/12751164/149138\">this answer</a>, or you can just read the standard for the official word.</p>\n\n<p>That said, what you may want to know is if the compiler will <em>treat</em> it as a constant, in cases where you call it with a constant value as in your example. The answer is \"yes\" for any decent compiler with optimization turned on. Call inlining and constant propagation are the magic that make this happen. The compiler will try to inline the call to <code>foo</code> and then substitute <code>10</code> for the argument, and will follow that recursively.</p>\n\n<p>Let's take a look at your example. I've slightly modified it to use <em>return foo(10)</em> in <code>main</code> so that the compiler doesn't optimize everything away entirely! I've also chosen gcc's <code>__builtin_popcount</code> as the unspecified function called by <code>foo()</code>. Check out <a href=\"https://godbolt.org/g/3oHkOM\" rel=\"nofollow\">this godbolt version</a> of your program without optimization, compiled in gcc 6.2. The assembly looks like:</p>\n\n<pre><code>foo(int):\n        push    rbp\n        mov     rbp, rsp\n        mov     DWORD PTR [rbp-4], edi\n        mov     eax, DWORD PTR [rbp-4]\n        popcnt  eax, eax\n        pop     rbp\n        ret\nmain:\n        push    rbp\n        mov     rbp, rsp\n        mov     edi, 10\n        call    foo(int)\n        pop     rbp\n        ret\n</code></pre>\n\n<p>It's straightforward. Most of the <code>foo()</code> is just setting up the stack frame and (pointlessly) pushing <code>edi</code> (the <code>varA</code> argument) on to the stack.</p>\n\n<p>When we call <code>foo()</code> from main, we pass <code>10</code> as the argument. So clearly the fact that it's a constant hasn't helped.</p>\n\n<p>OK, let's compile this with a more realistic <code>-O2</code> setting<sup>1</sup>. <a href=\"https://godbolt.org/g/8efLhM\" rel=\"nofollow\">Here's what we get</a>:</p>\n\n<pre><code>main:\n        mov     eax, 2\n        ret\n</code></pre>\n\n<p>That's it. The whole thing is just <code>return 2</code>, pretty much. So the compiler was definitely able to see that 10 is a constant value, and expand <code>foo(10)</code>. Furthermore, it was able to evaluate <code>foo(10)</code> completely, calculating the <a href=\"https://en.wikipedia.org/wiki/Hamming_weight\" rel=\"nofollow\">popcount</a> of 10 (0b1010 in binary) directly, without needing the <code>popcount</code> instruction at all, and just returning the answer <code>2</code>. </p>\n\n<p>Also note that the compiler didn't even generate any code for <code>foo()</code> all. That's because it can see it is declared <code>static inline</code><sup>2</sup> so it can only be called from within this compilation unit, and that there are actually no callers that need the full function since the only call-site was inlined. So foo just disappears.</p>\n\n<p>So what the standard says about compile-time constants only helps in understanding what a compiler <em>must</em> do, and where certain expressions may be <em>legally used</em>, but it doesn't help much in understanding what a compiler <em>will</em> do in practice with optimization.</p>\n\n<p>The key here was that your method <code>foo()</code> is declared in the same compilation unit as its caller, so the compiler could inline and effectively optimize across the two functions. If it were in a separate compilation unit, this could not happen, unless you use some options such as link-time code generation.</p>\n\n<hr>\n\n<p><sup>1</sup>As it turns out, pretty much <em>any</em> optimization setting here results in the same code, as the transformation is pretty trivial. </p>\n\n<p><sup>2</sup>In fact, <em>either</em> of <code>inline</code> or <code>static</code> is enough to make the function local to the compilation unit. If you omit both, however, a body for <code>foo()</code> will be generated since it could be called from a separately compiled unit. With optimization, the body looks like:</p>\n\n<pre><code>foo(int):\n        xor     eax, eax\n        popcnt  eax, edi\n        ret\n</code></pre>\n", "tags": ["c", "compile-time-constant"], "creation_date": 1476483080, "score": 3, "last_activity_date": 1476483080, "answer_id": 40052705, "is_accepted": true, "owner": {"user_id": 149138, "reputation": 6036, "user_type": "registered", "accept_rate": 67, "display_name": "BeeOnRope", "link": "http://stackoverflow.com/users/149138/beeonrope", "profile_image": "https://www.gravatar.com/avatar/cfd457233c8ebbab383475fc097442d9?s=128&d=identicon&r=PG"}, "title": "Compile-time const and formal parameters", "question_id": 40052323}