{"body": "<p>I am answering to this to give an idea about the scenario and solution as per the android developer site for others benefit. I have solved this using custom trust manager.</p>\n\n<p>The problem was with the server certificate, it misses intermediate certificate authority. However with the first flow certificate path is completed somehow and result was successful certificate path validation.</p>\n\n<p>There is a solution for this in <a href=\"https://developer.android.com/training/articles/security-ssl.html#MissingCa\" rel=\"nofollow\">android developer site</a>. it suggest to use custom trust manager that trusts this server certificate or it suggest to server to include the intermediate CA in the server chain.</p>\n\n<p>custom trust manager. source: <a href=\"https://developer.android.com/training/articles/security-ssl.html#UnknownCa\" rel=\"nofollow\">https://developer.android.com/training/articles/security-ssl.html#UnknownCa</a></p>\n\n<pre><code>// Load CAs from an InputStream\n// (could be from a resource or ByteArrayInputStream or ...)\nCertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n// From https://www.washington.edu/itconnect/security/ca/load-der.crt\nInputStream caInput = new BufferedInputStream(new FileInputStream(\"load-der.crt\"));\nCertificate ca;\ntry {\n    ca = cf.generateCertificate(caInput);\n    System.out.println(\"ca=\" + ((X509Certificate) ca).getSubjectDN());\n} finally {\n    caInput.close();\n}\n\n// Create a KeyStore containing our trusted CAs\nString keyStoreType = KeyStore.getDefaultType();\nKeyStore keyStore = KeyStore.getInstance(keyStoreType);\nkeyStore.load(null, null);\nkeyStore.setCertificateEntry(\"ca\", ca);\n\n// Create a TrustManager that trusts the CAs in our KeyStore\nString tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\nTrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\ntmf.init(keyStore);\n\n// Create an SSLContext that uses our TrustManager\nSSLContext context = SSLContext.getInstance(\"TLS\");\ncontext.init(null, tmf.getTrustManagers(), null);\n// Tell the okhttp to use a SocketFactory from our SSLContext\nOkHttpClient okHttpClient client = new OkHttpClient.Builder().sslSocketFactory(context.getSocketFactory()).build();\n</code></pre>\n", "tags": ["java", "android", "security", "ssl", "okhttp3"], "creation_date": 1472815350, "score": 0, "last_activity_date": 1472815350, "answer_id": 39291151, "is_accepted": true, "owner": {"user_id": 2341815, "reputation": 360, "user_type": "registered", "accept_rate": 53, "display_name": "Ruwanka Madhushan", "link": "http://stackoverflow.com/users/2341815/ruwanka-madhushan", "profile_image": "https://www.gravatar.com/avatar/637ab45a810d6286bfa97ff77b505eaa?s=128&d=identicon&r=PG"}, "title": "Android java.security.cert.CertPathValidatorException: Trust anchor for certification path not found", "question_id": 39264056}