{"body": "<p>Actually @Rubins might be close--String isn't a primitive but the compiler should be freely able to rely on the fact that a reference to a given string is a constant.</p>\n\n<p>If you were to call a pure function that didn't rely on any external information (Something I believe Java can figure out), Java could safely short-circuit the entire call if it was only being passed strings.</p>\n\n<p>Let's say the function f is just:</p>\n\n<pre><code>public static String f(String a, String b){return a+b}\n</code></pre>\n\n<p>then:</p>\n\n<pre><code>str1=\"a\"\nstr2=\"b\"\nstr3=str2 // Note that now &amp;str3 == &amp;str2, they reference the same object\n\nx=f(str1, str2) // \"ab\"\ny=f(str1, str3) // \"ab\"\n</code></pre>\n\n<p>Java can see this pattern, that any time f is called with (&amp;str1 and &amp;str2) it can just return \"ab\" and not even execute the call.</p>\n\n<pre><code>str3=\"c\" // Now you are changing &amp;str3 to be != &amp;str2\ny=f(str1, str3) // \"ac\", but since the second address passed in is \n                // different, Java knows not to just return \"ab\"\n</code></pre>\n\n<p>In essence, the call to f(str1, str2) is passing 2 \"pointers\" (kinda), but since they are immutable strings Java can be certain that if f is EVER called with the same two pointers (&amp;str1 and &amp;str2 to steal a little c notation) it can just return the same thing it did last time.</p>\n\n<p>When f(array) is called, however, the call cannot be shortcut because:</p>\n\n<pre><code>public static String f(String[] a){return a[0]+a[1]}\n\nString[] array =new String(){\"a\",\"b\"};\nx=f(array); // will be \"ab\" for f(&amp;array)\narray[1]=\"c\";\ny=f(array); // is now \"ac\" for same f(&amp;array)!  Can't shortcut!\n</code></pre>\n\n<p>Assuming f is a pure function (that doesn't reference any external variables), the string version cannot fail to assert--the results must be the same for the same address parameters.</p>\n\n<p>For the array, it must call and pass the array or recursively test the contents of the entire array and all it's children every time.</p>\n\n<p>I'm not certain this is what's going on, but I'd bet a few bucks on it.</p>\n\n<p>Immutability is fairly useful and a pretty good habit, there is a good reason Java Strings are immutable.</p>\n\n<p>It might be interesting to pass in two simple mutable objects (with just one non-final field) and see how it performs.</p>\n\n<p>(Sorry if my c/reference terminology is off, I think it's right but I haven't dealt with C in decades.  I also realize I'm probably missing a level of dereferencing in Java since objects in memory can move, but I think optimization knows that and the system acts as I've described.)</p>\n", "last_edit_date": 1477090898, "creation_date": 1477090537, "score": 0, "last_activity_date": 1477090898, "answer_id": 40186506, "is_accepted": true, "owner": {"user_id": 12943, "reputation": 43824, "user_type": "registered", "accept_rate": 86, "display_name": "Bill K", "link": "http://stackoverflow.com/users/12943/bill-k", "profile_image": "https://www.gravatar.com/avatar/d6a9924b767fe91c46def7edc7bce035?s=128&d=identicon&r=PG"}, "title": "Why is passing two string arguments more efficient than one list argument", "question_id": 40165758}