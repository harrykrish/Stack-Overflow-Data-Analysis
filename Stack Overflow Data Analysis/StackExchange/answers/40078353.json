{"body": "<ul>\n<li>Do not use \"prefix\" indexing such as <code>sensor_name(11)</code>; it rarely helps and sometimes hurts.</li>\n<li>If you sensor name and type, and data_type can't be more than 255 characters, don't use <code>TEXT</code>; instead <code>VARCHAR(...)</code> with some realistic limit.</li>\n<li>Normalize sensor name and type, and data_type -- I assume they are repeated a lot.  <code>ENUM</code> is a reasonable alternative.</li>\n<li>KEY(timestamp) and KEY(timestamp, ...) are redundant; DROP the former.</li>\n<li>Your table needs a <code>PRIMARY KEY</code>.  If no column (or set of columns) is Unique, then use an <code>AUTO_INCREMENT</code>.</li>\n<li>Perhaps you don't want to <em>start</em> the <code>GROUP BY</code> with the exact timestamp.  Maybe truncate to the hour?  For example, <code>CONCAT(LEFT(timestamp, 13), ':xx')</code> would yield something like <code>2016-10-16 20:xx</code>.</li>\n<li>The main reason the query is taking a long time is that it is outputing 418K rows.  What will you do with that many rows?  I see no <code>LIMIT</code>, nor <code>ORDER BY</code>.  Will that continue to be the case?</li>\n<li>Partitioning and sharding will not help the speed any.</li>\n</ul>\n\n<p>Those suggestions will help in various ways.  Once you have fixed most of them, we can discuss how to use Summary Tables to get a 10x speedup.</p>\n", "tags": ["mysql", "performance"], "creation_date": 1476677270, "score": 1, "last_activity_date": 1476677270, "answer_id": 40078353, "is_accepted": true, "owner": {"user_id": 1766831, "reputation": 24874, "user_type": "registered", "display_name": "Rick James", "link": "http://stackoverflow.com/users/1766831/rick-james", "profile_image": "https://www.gravatar.com/avatar/1ee974306d2def46eb69534fbcf95cc5?s=128&d=identicon&r=PG"}, "title": "How to solve performance GROUP BY issue in MySQL?", "question_id": 40069374}