{"title": "Iterative quantile estimation in Matlab", "tags": ["matlab", "iteration", "estimation", "quantile"], "creation_date": 1477673261, "score": 0, "body": "<p>After trying some of the adaptive iterative approaches that I found in literature without great success (not sure, if I did it right), I came up with a solution that gives me good results for my test samples and also for the actual Monte-Carlo-Simulation.</p>\n\n<p>I buffer a subset of simulation results, compute the sample quantiles and average over all subset sample quantiles in the end. This seems to work quite well and without tuning many parameters. The only parameter is the buffer size which is 100 in my case.</p>\n\n<p>The results converge quite fast and increasing sample size does not improve the results dramatically. There seems to be a small but constant bias that presumably is the averaged error of the subset sample quantiles. And that is the downside of my solution. By choosing the buffer size, one fixes the achievable accuracy. Increasing the buffer size reduces this bias. In the end, it seems to be a memory and accuracy tradeoff.</p>\n\n<pre><code>% Generate data\nrng('default');\ndata = sqrt(0.5) * randn(10000, 1) + 5 * rand(10000, 1) + 10;\n\n% Set parameters\nprobabilities = 0.2;\n\n% Compute reference sample quantiles\nquantileEstimation1 = quantile(data, probabilities);\n\n% Estimate quantiles with computing the mean over a number of subset\n% sample quantiles\nsubsetSize = 100;\nquantileSum = 0;\nfor index = 1:length(data) / subsetSize;\n\n    quantileSum = quantileSum + quantile(data(((index - 1) * subsetSize + 1):(index * subsetSize)), probabilities);\n\nend\nquantileEstimation2 = quantileSum / (length(data) / subsetSize);\n\n% Estimate quantiles with iterative computation\nquantileEstimation3 = zeros(size(probabilities));\nindicator = zeros(size(probabilities));\ncontrolFactor = 2 * sqrt(2 * pi);\nfor index = 1:length(data)\n\n    control = controlFactor / index;\n    indices = (data(index) &gt;= quantileEstimation3);\n    indicator(indices) = probabilities(indices);\n    indices = (data(index) &lt; quantileEstimation3);\n    indicator(indices) = probabilities(indices) - 1;\n    quantileEstimation3 = quantileEstimation3 + control * indicator;\n\nend\n\nfprintf('Reference result: %f\\nSubset result: %f\\nIterative result: %f\\n\\n', quantileEstimation1, quantileEstimation2, quantileEstimation3);\n</code></pre>\n", "last_activity_date": 1477676770, "answer_id": 40309639, "is_accepted": false, "owner": {"user_id": 5508921, "reputation": 3, "user_type": "registered", "display_name": "JotWe", "link": "http://stackoverflow.com/users/5508921/jotwe", "profile_image": "https://i.stack.imgur.com/lTX3c.png?s=128&g=1"}, "last_edit_date": 1477676770, "question_id": 40291135}