{"title": "Get KProperty of a non-package extension property", "tags": ["kotlin"], "creation_date": 1476700854, "score": 3, "body": "<p>The error you are getting is:</p>\n\n<blockquote>\n  <p>Error:(y, x) Kotlin: 'extProp' is a member and an extension at the same time. References to such elements are not allowed</p>\n</blockquote>\n\n<p>There is <strong>no syntax</strong> mechanism to generate a reference to an extension method that also requires a containing class.  Your extension for example might use members of the class, and this would need something like \"<a href=\"https://github.com/Kotlin/KEEP/issues/5\" rel=\"nofollow\">bound references</a>\" coming in Kotlin 1.1 (which I'm not sure will cover this case either, it is currently an <a href=\"https://github.com/Kotlin/KEEP/blob/master/proposals/bound-callable-references.md#open-questions\" rel=\"nofollow\">open question</a>).  So for now, there is <strong>no <code>::</code> syntax</strong> available.  Things like <code>Example::String::extProp</code> are <strong>not</strong> available, neither is the commonly tried <code>Example::String.extProp</code> syntax.  But you can find it by reflection.</p>\n\n<p>First you need to know the type you will receive is:</p>\n\n\n\n<pre><code>KProperty2&lt;INSTANCE, EXTENDING, PROPTYPE&gt;\n</code></pre>\n\n<p>Whereas a normal property on a class is:</p>\n\n<pre><code>KProperty1&lt;INSTANCE, PROPTYPE&gt;\n</code></pre>\n\n<p>You need to know that because any call to the <code>getter</code> will require the class instance and an instance of the class the property is extending.  So you cannot call it the same way as you would a property reference of a class.  </p>\n\n<p>You can use this function to find an extension property declared in a class:</p>\n\n<pre><code>@Suppress(\"UNCHECKED_CAST\")\nfun &lt;T: Any, EXTENDING: Any, R: Any&gt; KClass&lt;T&gt;.extProp(extends: KClass&lt;EXTENDING&gt;, name: String, returning: KClass&lt;R&gt;): KProperty2&lt;T, EXTENDING, R&gt; {\n    return this.declaredMemberExtensionProperties.first {\n        it.name == name &amp;&amp;\n                it.parameters.size == 2 &amp;&amp;\n                it.parameters[0].kind == KParameter.Kind.INSTANCE &amp;&amp; it.parameters[0].type == this.defaultType &amp;&amp;\n                it.parameters[1].kind == KParameter.Kind.EXTENSION_RECEIVER &amp;&amp; it.parameters[1].type == extends.defaultType &amp;&amp;\n                it.returnType == returning.defaultType\n    } as KProperty2&lt;T, EXTENDING, R&gt;\n}\n</code></pre>\n\n<p>This is a bit overkill for the checking but ensures that it is future-proof in case any other types of extensions are added later.  The following is your code updated to use it:</p>\n\n<pre><code>class Example() {\n    val String.extProp: String\n        get() = \"howdy $this\"\n\n    fun foo() {\n        val prop = Example::class.extProp(String::class, \"extProp\", String::class)\n        println(prop.get(this, \"stringy\"))  // \"howdy stringy\"\n    }\n}\n</code></pre>\n", "last_activity_date": 1476705089, "answer_id": 40084275, "is_accepted": true, "owner": {"user_id": 3679676, "reputation": 12075, "user_type": "registered", "accept_rate": 100, "display_name": "Jayson Minard", "link": "http://stackoverflow.com/users/3679676/jayson-minard", "profile_image": "https://www.gravatar.com/avatar/c0faaf44a8922cf165ff73d9efd0dade?s=128&d=identicon&r=PG"}, "last_edit_date": 1476705089, "question_id": 40065838}