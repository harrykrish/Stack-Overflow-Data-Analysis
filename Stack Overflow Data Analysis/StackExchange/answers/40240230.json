{"title": "what is the optimal Multithreading scenario for processing a long file lines?", "tags": ["c++", "multithreading", "performance", "io"], "creation_date": 1477399181, "score": 1, "body": "<p>An other approach could be interleaved thread.\nReading is done by every thread, but only 1 at once.\nBecause of the waiting in the very first iteration, the \nthreads will be interleaved. </p>\n\n<p>But this is only an scaleable option, if <code>work()</code> is the bottleneck\n(then every non-parallel execution would be better)</p>\n\n<p>Thread:</p>\n\n<pre><code>while (!end) {\n    // should be fair!\n    lock();\n    read();\n    unlock();\n\n    work();\n}\n</code></pre>\n\n<p>basic example: (you should probably add some error-handling)</p>\n\n<pre><code>void thread_exec(ifstream* file,std::mutex* mutex,int* global_line_counter) {\n    std::string line;\n    std::vector&lt;std::string&gt; data;\n    int i;\n    do {\n        i = 0;\n        // only 1 concurrent reader\n        mutex-&gt;lock();\n        // try to read the maximum number of lines\n        while(i &lt; MAX_NUMBER_OF_LINES_PER_ITERATION &amp;&amp; getline(*file,line)) {\n            // only the even lines we want to process\n            if (*global_line_counter % 2 == 0) {\n                data.push_back(line);\n                i++;\n            }\n            (*global_line_counter)++;\n\n        }\n        mutex-&gt;unlock();\n\n        // execute work for every line\n        for (int j=0; j &lt; data.size(); j++) {\n            work(data[j]);\n        }\n\n        // free old data\n        data.clear();\n     //until EOF was not reached\n   } while(i == MAX_NUMBER_OF_LINES_PER_ITERATION);\n\n}\n\nvoid process_data(std::string file) {\n     // counter for checking if line is even\n     int global_line_counter = 0;\n     // open file\n     ifstream ifstr(file.c_str());\n     // mutex for synchronization\n     // maybe a fair-lock would be a better solution\n     std::mutex mutex;\n     // create threads and start them with thread_exec(&amp;ifstr, &amp;mutex, &amp;global_line_counter);\n     std::vector&lt;std::thread&gt; threads(NUM_THREADS);\n     for (int i=0; i &lt; NUM_THREADS; i++) {\n         threads[i] = std::thread(thread_exec, &amp;ifstr, &amp;mutex, &amp;global_line_counter);\n     }\n     // wait until all threads have finished\n     for (int i=0; i &lt; NUM_THREADS; i++) {\n         threads[i].join();\n     }\n}\n</code></pre>\n", "last_activity_date": 1477699968, "answer_id": 40240230, "is_accepted": true, "owner": {"user_id": 4936507, "reputation": 149, "user_type": "registered", "display_name": "Domso", "link": "http://stackoverflow.com/users/4936507/domso", "profile_image": "https://www.gravatar.com/avatar/36df2f476a2ed16bb905fc814370f720?s=128&d=identicon&r=PG&f=1"}, "last_edit_date": 1477699968, "question_id": 40239090}