{"title": "How to make windows slim read writer lock fair?", "tags": ["c++", "windows", "readerwriterlockslim"], "creation_date": 1476378264, "score": 0, "body": "<p>It is unlikely you can change the slim lock itself to be fair, especially since the documentation doesn't indicate any method of doing so, and most locks today are <em>unfair</em> for performance reasons.</p>\n\n<p>That said, it is fairly straightforward to roll your own approximately FIFO lock with Windows <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms682655(v=vs.85).aspx\" rel=\"nofollow\">events</a>, and a 64-bit control word that you manipulate with <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms683562(v=vs.85).aspx\" rel=\"nofollow\">compare and swap</a> that is still very slim. Here's an outline:</p>\n\n<p>The state of the lock is reflected in the control word is manipulated atomically to transition between the states, and allows threads to enter the lock (if allowed) with a single atomic operation and no kernel switch (that's the performance part of \"slim\"). The reset events are used to notify waiting threads, when threads need to block and can be allocated on-demand (that's the low memory footprint of slim).</p>\n\n<p>The lock control word has the follow states:</p>\n\n<ol>\n<li><p>Free - no readers or writers, and no waiters. Any thread can acquire the lock for reading or writing by atomically transitioning the lock into state (2) or (3).</p></li>\n<li><p>N readers in the lock. There are <em>N</em> readers in the lock at the moment. New readers can immediately acquire the lock by adding 1 to the count - use a field of 30-bits or so within the control word to represent this count. Writers must block (perhaps after spinning). When readers leave the lock, they decrement the count, which may transition to state (1) when the last reader leaves (although they don't need to do anything special in a (2) -> (1) transition).</p></li>\n<li><p>State (2) + waiting writers + 0 or more waiting readers. In this state, there are 1 or more readers still in the lock, but at least one waiting writer. The writers should wait on a manual-reset event, which is designed, although not guaranteed, to be FIFO. There is a field in the control word to indicate how many writers are waiting. In this state, new readers that want to enter the lock cannot, and set a reader-waiting bit instead, and block on the reader-waiting event. New writers increment the waiting writer count and block on the writer-waiting event. When the last reader leaves (setting the reader-count field to 0), it <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms686211(v=vs.85).aspx\" rel=\"nofollow\">signals</a> the writer-waiting event, releasing the longest-waiting writer to enter the lock.</p></li>\n<li><p>Writer in the lock. When a writer is in the lock, all readers queue up and wait on the reader-waiting event. All incoming writers increment the waiting-writer count and queue up as usual on the writer-waiting event. There may even be some waiting readers when the writer acquires the lock because of state (3) above, and these are treated identically. When the writer leaves the lock, it checks for waiting writers and readers and either unblocks a writer or all readers, depending on policy, discussed below.</p></li>\n</ol>\n\n<p>All the state transitions discussed above are done atomically using compare-and-swap. The typical pattern is that any of the <code>lock()</code> or <code>unlock()</code> calls look at the control word, determine what state they are in and what transition needs to happen (following the rules above), calculate the new control word in a temporary then <em>attempt</em> to swap in the new control word with compare-and-swap. Sometimes that attempt fails because another thread concurrently modified the control word (e.g., another reader entered the lock, incrementing the reader count). No problem, just start over from \"determine state...\" and try again. Such races are rare in practice since the state word calculation is very short, and that's just how things work with CAS-based complex locks.</p>\n\n<p>This lock design is \"slim\" is almost every sense. Performance-wise, it is near the top of what you can get for a general purpose design. In particular, the common fast-paths of (a) reader entering the lock with 0 or more readers already in the block (b) reader leaving the lock with 0 or more readers still in the lock and (c) writer entering/leaving an uncontended lock are all about as fast as possible in the usual case: a single atomic operation. Furthermore, the reader entry and exit paths are \"lock free\" in the sense that incoming readers do not temporarily take an mutex internal to the rwlock, manipulate state, and then unlock it while entering/leaving the lock. This approach is slow and subject to issues whenever a reader thread performs a context switch at the critical moment in holds the internal lock. Such approaches do not scale to heaver reader activity with a short rwlock critical section: even though multiple readers can, in theory, enter the critical section, they all bottleneck on entering and leaving the internal lock (which happens twice for every enter/exit operation) and performance is worse than a normal mutex!</p>\n\n<p>It is also lightweight in that it only needs a couple of Windows Event objects, and these objects can be allocated <em>on demand</em> - they are only needed when contention occurs and a state transition that requires blocking is about to occur. That's how <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms682530(v=vs.85).aspx\" rel=\"nofollow\">CRITICAL_SECTION</a> objects work. </p>\n\n<p>The lock above is <em>fair</em> in the sense that readers won't block writers, and writers are served in FIFO order. How writers interact with waiting readers is up to your policy for who to unblock when the lock becomes free after a writer unlocks and there are <em>both</em> waiting readers and writers. On simple policy is to unblock all waiting readers.</p>\n\n<p>In this design, writers will alternate in FIFO order with FIFO batches of readers. Writers are FIFO relative to other writers, and reader batches are FIFO relative to other reader batches, but the relationship between writers and readers isn't <em>exactly</em> FIFO: because all incoming readers are added to the same reader-waiting set, in the case that there are already several waiting writers, arriving readers all go into the next \"batch\" to be released, which actually puts them ahead of writers that are already waiting. That's quite reasonable though: readers all go <em>at once</em>, so adding more readers to the batch doesn't necessary cost much and probably increases efficiency, and if you did serve everything thread in strict FIFO order, the lock would reduce in behavior to a simple mutex under contention.</p>\n\n<p>Another possible design is to always unblock writers if any are waiting. This favors writers at the expense of readers and does mean that a never-ending stream of writers could block out readers indefinitely. This approach makes sense where you know your writes are latency sensitive important and you either aren't worried about reader starvation, or you know it can't occur due to the design of your application (e.g., because there is only one possible writer at a time).</p>\n\n<p>Beyond that, there are a lot of other policies possible, such as favoring writers up until readers have been waiting for a certain period, or limiting reader batch sizes, or whatever. They are mostly possible to implement efficiently since the bookkeeping is generally limited to the slow paths where threads will block anyway.</p>\n\n<p>I've glossed over some implementation details and gotchas here (in particular, the need to be careful when making the transitions that involve blocking to avoid \"missed wakeup\" issues) - but this definitely works. I've written such a lock before the slim rwlock existed to fill the need for a fast high-performance rwlock, and it performs very well. Other tradeoffs are possible too, e.g., for designs in which reads are expected to dominate, contention can be reduced by splitting up the control word across cache lines, at the cost of more expensive write operations. </p>\n\n<p>One final note - this lock is a bit fatter, in memory use, than the Windows one in the case that is contended - because it allocates one or two windows Events <em>per lock</em>, while the slim lock avoids this. The slim lock likely does it by directly supporting the slim lock behavior in the kernel, so the control word can directly be used as part of the kernel-side waitlist. You can't reproduce that exactly, but you can still remove the per-lock overhead in another way: use thread-local storage to allocate your two events <em>per thread</em> rather than per lock. Since a thread can only be waiting on one lock at a time, you only need this structure one per thread. That brings it into line with slim lock in memory use (unless you have very few locks and a ton of threads). </p>\n", "last_activity_date": 1476381264, "answer_id": 40026997, "is_accepted": false, "owner": {"user_id": 149138, "reputation": 6036, "user_type": "registered", "accept_rate": 67, "display_name": "BeeOnRope", "link": "http://stackoverflow.com/users/149138/beeonrope", "profile_image": "https://www.gravatar.com/avatar/cfd457233c8ebbab383475fc097442d9?s=128&d=identicon&r=PG"}, "last_edit_date": 1476381264, "question_id": 40025600}