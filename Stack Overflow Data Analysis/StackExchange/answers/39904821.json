{"body": "<p>The confusing nature of the effect (the assembled code doesn't change!) you are seeing is due to <em>section alignment</em>. When using the <a href=\"http://www.nasm.us/doc/nasmdoc4.html#section-4.11.12\" rel=\"nofollow\"><code>ALIGN</code></a> macro in NASM, it actually has two separate effects:</p>\n\n<ol>\n<li><p>Add 0 or more <code>nop</code> instructions so that the next instruction is aligned to the specified power-of-two boundary.</p></li>\n<li><p>Issue an implicit <code>SECTALIGN</code> macro call which will set the <em>section</em> alignment directive to alignment amount<sup>1</sup>.</p></li>\n</ol>\n\n<p>The first point is the commonly understood behavior for align. It aligns the loop relatively within the section in the output file.</p>\n\n<p>The second part is also needed however: imagine your loop was aligned to a 32 byte boundary in the assembled section, but then the runtime loader put your section, in memory, at an address aligned only to 8 bytes: this would make the in-file alignment quite pointless. To fix this, most executable formats allow each section to specify an <a href=\"http://stackoverflow.com/questions/2391865/what-is-alignment-field-in-binary-formats-why-is-it-needed\">alignment requirement</a>, and the runtime loader/linker will be sure to load the section at a memory address which respects the requirement.</p>\n\n<p>That's what the hidden <a href=\"http://www.nasm.us/doc/nasmdoc4.html#section-4.11.13\" rel=\"nofollow\"><code>SECTALIGN</code></a> macro does - it ensures that your <code>ALIGN</code> macro works.</p>\n\n<p>For your file, there is no difference in the assembled code between <code>ALIGN 16</code> and <code>ALIGN 32</code> because the next 16-byte boundary happens to also be the next 32-byte boundary (of course, every other 16-byte boundary is a 32-byte one, so that happens about half the time). The implicit <code>SECTALIGN</code> call is still different though, <em>and that's the one byte difference</em> you see in your hexdump. The 0x20 is decimal 32, and the 0x10 is decimal 16.</p>\n\n<p>You can verify this with <code>objdump -h &lt;binary&gt;</code>. Here's an example on a binary I aligned to 32 bytes:</p>\n\n<pre><code>objdump -h loop-test.o\n\nloop-test.o:     file format elf64-x86-64\n\nSections:\nIdx Name          Size      VMA               LMA               File off  Algn\n  0 .text         0000d18a  0000000000000000  0000000000000000  00000180  2**5\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n</code></pre>\n\n<p>The <code>2**5</code> in the <code>Algn</code> column is the 32-byte alignment. With 16-byte alignment this changes to <code>2**4</code>.</p>\n\n<p>Now it should be clear what happens - aligning the first function in your example changes the section alignment, but not the assembly. When you linked your program together, the linker will merge the various <code>.text</code> sections and pick the highest alignment.</p>\n\n<p>At runtime, then this causes the code to be aligned to a 32-byte boundary - but this doesn't affect the first function, because it isn't alignment sensitive. Since the linker has merged your object files into one section, the larger alignment of 32 changes the alignment of <em>every</em> function (and instruction) in the section, including your other method, and so it changes the performance of your <em>other</em> function, which <em>is</em> alignment-sensitive.</p>\n\n<hr>\n\n<p><sup>1</sup>To be precise, <code>SECTALIGN</code> only changes the section alignment if the current section alignment is less than the specified amount - so the final section alignment will be the same as the <em>largest</em> <code>SECTALIGN</code> directive in the section.</p>\n", "tags": ["c", "assembly", "x86", "nasm", "avx"], "creation_date": 1475784559, "score": 1, "last_activity_date": 1475784559, "answer_id": 39904821, "is_accepted": true, "owner": {"user_id": 149138, "reputation": 6036, "user_type": "registered", "accept_rate": 67, "display_name": "BeeOnRope", "link": "http://stackoverflow.com/users/149138/beeonrope", "profile_image": "https://www.gravatar.com/avatar/cfd457233c8ebbab383475fc097442d9?s=128&d=identicon&r=PG"}, "title": "Code alignment in one object file is affecting the performance of a function in another object file", "question_id": 25958649}