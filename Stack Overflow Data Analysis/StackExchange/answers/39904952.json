{"body": "<p>I. I was able to recreate your issue with a code like this</p>\n\n<pre><code>class Manager\n  def self.run(a, b)\n    new(a, b)\n  end\nend\n\nRSpec.configure do |config|\n  config.mock_with :rspec do |mocks|\n    mocks.verify_partial_doubles = true\n  end\nend\n\nRSpec.describe Manager, type: :api do\n  let(:a) { 1 }\n  let(:b) { 2 }\n\n  describe '#run' do\n    it 'instantiates the class with 2 arguments' do\n      expect(Manager).to receive(:new).with(a, b)\n      Manager.run(a, b)\n    end\n  end\nend\n</code></pre>\n\n<p>Which results in:</p>\n\n<pre><code>1) Manager#run instantiates the class with 2 arguments\n   Failure/Error: expect(Manager).to receive(:new).with(a, b)\n     Wrong number of arguments. Expected 0, got 2.\n</code></pre>\n\n<p>This happens because of the <a href=\"https://relishapp.com/rspec/rspec-mocks/v/3-5/docs/verifying-doubles/partial-doubles\" rel=\"nofollow\">verifying functionality</a>. When this setting is enabled (and it should be), RSpec will make sure the the object implements the interface that is being stubbed/mocked. In this case RSpec throws an error on the line <code>expect(Manager).to receive(:new).with(a, b)</code>, because it actually looks into the <code>Manager</code> class and checks whether initialize can take 2 arguments.</p>\n\n<p>If you change the manager to look like this the example will pass:</p>\n\n<pre><code>class Manager\n  attr_reader :a, :b\n\n  def initialize(a, b)\n    @a = a\n    @b = b\n  end\n\n  def self.run(a, b)\n    new(a, b)\n  end\nend\n</code></pre>\n\n<p>II. But you don't really need to use mocks for functionality like this. If you are just checking whether the right kind of instance is returned it is better to just look at the real thing.</p>\n\n<pre><code>RSpec.describe Manager, type: :api do\n  let(:a) { 1 }\n  let(:b) { 2 }\n\n  describe '#run' do\n    subject { described_class.run(a, b) }\n\n    it 'instantiates the class with 2 arguments' do\n      expect(subject).to be_an_instance_of(Manager)\n    end\n\n    it 'sets a to the first argument' do\n      expect(subject.a).to eq(a)\n    end\n\n    it 'sets b to the second argument' do\n      expect(subject.b).to eq(b)\n    end\n  end\nend\n</code></pre>\n\n<p>III. In this example:</p>\n\n<pre><code>expect(Manager).to receive(:run).with(first_arg, second_arg)\nManager.run(first_arg, second_arg)\n</code></pre>\n\n<p>You set up an assertion, and then immediately called the code to pass that assertion. So weren't really testing anything.</p>\n\n<p>Mocking/stubbing correctly is fairly advanced testing concept, and it is easy to get it wrong so if you can go without it, just go without, it will make things easier.</p>\n\n<p>If you want to learn more about what to test/when to mock. I recommend this talk by Sandi Metz. <a href=\"https://www.youtube.com/watch?v=URSWYvyc42M\" rel=\"nofollow\">https://www.youtube.com/watch?v=URSWYvyc42M</a></p>\n", "tags": ["ruby-on-rails", "ruby", "rspec"], "creation_date": 1475785122, "score": 2, "last_activity_date": 1475785122, "answer_id": 39904952, "is_accepted": true, "owner": {"user_id": 6156030, "reputation": 733, "user_type": "registered", "display_name": "Laura Paakkinen", "link": "http://stackoverflow.com/users/6156030/laura-paakkinen", "profile_image": "https://www.gravatar.com/avatar/6ab58120061222262e44544b199af476?s=128&d=identicon&r=PG&f=1"}, "title": "RSpec and Object Initialization in Ruby", "question_id": 39903939}