{"title": "What kind of C11 data type is an array according to the AMD64 ABI", "tags": ["c", "assembly", "types", "x86-64", "calling-convention"], "creation_date": 1470453158, "score": 6, "body": "<p><strong>Bare</strong> arrays as function args in C and C++ <em>always</em> decay to pointers, just like in several other contexts.</p>\n\n<p>Arrays inside <code>struct</code>s or <code>union</code>s don't, and are passed by value.  This is why ABIs need to care about how they're passed, even though it doesn't happen in C for bare arrays.</p>\n\n<hr>\n\n<p>As <a href=\"http://stackoverflow.com/questions/38800044/what-kind-of-c11-data-type-is-an-array-according-to-the-amd64-abi?noredirect=1#comment64984850_38800044\">Keith Thomson points out</a>, the relevant part of the C standard is <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf#page=151\" rel=\"nofollow\">N1570 section 6.7.6.3 paragraph 7</a></p>\n\n<blockquote>\n  <p>A declaration of a parameter as \"array of type\" shall be adjusted to\n  \"qualified pointer to type\", where the type qualifiers (if any) are\n  those specified within the [ and ] of the array type derivation ... <em>(stuff about <code>foo[static 10]</code>, see below)</em></p>\n</blockquote>\n\n<p>Note that multidimensional arrays work as arrays of array type, so only the outer-most level of \"array-ness\" is converted to a pointer to array type.</p>\n\n<hr>\n\n<p>Terminology:  The x86-64 ABI doc uses the same terminology as ARM, where <code>struct</code>s and arrays are \"aggregates\" (multiple elements at sequential addresses).  So the phrase \"aggregates and unions\" comes up a lot, because <code>union</code>s are handled similarly by the language and the ABI.</p>\n\n<p>It's the recursive rule for handling composite types (struct/union/class) that brings the array-passing rules in the ABI into play.  <strong>This is the only way you'll see asm that copies an array to the stack as part of a function arg, for C or C++</strong></p>\n\n<pre><code>struct s { int a[8]; };\nvoid ext(struct s byval);\n\nvoid foo() { struct s tmp = {{0}}; ext(tmp); }\n</code></pre>\n\n<p><a href=\"http://gcc.godbolt.org/#compilers:!((compiler:g6,options:&#39;-xc+-std%3Dgnu11+-Wall+-Wextra+-O3+-fverbose-asm&#39;,source:&#39;struct+s+%7B+int+a%5B8%5D%3B+%7D%3B%0Avoid+ext(struct+s+byval)%3B%0A%0Avoid+foo()+%7B+struct+s+tmp+%3D+%7B%7B0%7D%7D%3B+ext(tmp)%3B+%7D%0A&#39;)),filterAsm:(commentOnly:!t,directives:!t,intel:!t,labels:!t),version:3\" rel=\"nofollow\">gcc6.1 compiles it (for the AMD64 SysV ABI, with <code>-O3</code>)</a> to the following:</p>\n\n<pre><code>    sub     rsp, 40    # align the stack and leave room for `tmp` even though it's never stored?\n    push    0\n    push    0\n    push    0\n    push    0\n    call    ext\n    add     rsp, 72\n    ret\n</code></pre>\n\n<hr>\n\n<p>In the x86-64 ABI, pass-by-value happens by actual copying (into registers or the stack), not by hidden pointers.</p>\n\n<p>Note that return-by-value does pass a pointer as a \"hidden\" first arg (in <code>rdi</code>), when the return value is too large to fit in the 128bit concatenation of <code>rdx:rax</code> (and isn't a vector being returned in vector regs, etc. etc.)</p>\n\n<p>It would be possible for the ABI to use a hidden pointer to pass-by-value objects above a certain size, and trust the called function not to modify the original, but that's not what the x86-64 ABI chooses to do.  That would be better in some cases (especially for inefficient C++ with lots of copying without modification (i.e. wasted)), but worse in other cases.</p>\n\n<p><strong>SysV ABI bonus reading</strong>: As the <a href=\"/questions/tagged/x86\" class=\"post-tag\" title=\"show questions tagged &#39;x86&#39;\" rel=\"tag\">x86</a> tag wiki points out, the current version of the ABI standard doesn't fully document the behaviour that compilers rely on: <a href=\"http://stackoverflow.com/questions/36706721/is-a-sign-or-zero-extension-required-when-adding-a-32bit-offset-to-a-pointer-for/36760539#36760539\">clang/gcc sign/zero extend narrow args to 32bit</a>.</p>\n\n<hr>\n\n<p>Note that to really guarantee that a function arg is a fixed-size array, <strong><a href=\"http://en.cppreference.com/w/c/keyword/static\" rel=\"nofollow\">C99 and later lets you use the <code>static</code> keyword in a new way</a></strong>: on array sizes.  (It's still passed as a pointer, of course.  This doesn't change the ABI).</p>\n\n<pre><code>void bar(int arr[static 10]);\n</code></pre>\n\n<p>This lets <code>sizeof(arr)</code> work as you might expect inside the called function, and allows compiler warnings about going out of bounds.  It also potentially enables better optimization if the compiler knows it's allowed to access elements that the C source doesn't.  (See <a href=\"https://hamberg.no/erlend/posts/2013-02-18-static-array-indices.html\" rel=\"nofollow\">this blog post</a>).</p>\n\n<p><a href=\"http://en.cppreference.com/w/cpp/keyword/static\" rel=\"nofollow\">The same keyword page for C++</a> indicates that ISO C++ does not support this usage of <code>static</code>; it's another one of those C-only features, along with C99 variable-length-arrays and a few other goodies that C++ doesn't have.</p>\n\n<p>In C++, you can use <a href=\"http://en.cppreference.com/w/cpp/container/array\" rel=\"nofollow\"><code>std::array&lt;int,10&gt;</code></a> to get compile-time size information passed to the caller.  However, you have to manually pass it by reference if that's what you want, since it's of course just a class containing an <code>int arr[10]</code>.  <em>Unlike a C-style array, it doesn't decay to <code>T*</code> automatically.</em></p>\n\n<hr>\n\n<p><strong>The ARM doc that you linked</strong> doesn't seem to actually call arrays an aggregate type:  <em>Section 4.3 Composite Types</em> (which discusses alignment) distinguishes arrays from aggregate types, even though they appear to be a special case of its definition for aggregates.</p>\n\n<blockquote>\n  <p>A Composite Type is a collection of one or more Fundamental Data Types that are handled as a single entity at the\n  procedure call level. A Composite Type can be any of:</p>\n  \n  <ul>\n  <li>An aggregate, where the members are laid out sequentially in memory</li>\n  <li>A union, where each of the members has the same address</li>\n  <li>An array, which is a repeated sequence of some other type (its base type).</li>\n  </ul>\n  \n  <p>The definitions are recursive; that is, each of the types may contain a Composite Type as a member</p>\n</blockquote>\n\n<p>\"Composite\" is an umbrella term that includes arrays, structs, and unions.</p>\n", "last_activity_date": 1477724330, "answer_id": 38800192, "is_accepted": true, "owner": {"user_id": 224132, "reputation": 43916, "user_type": "registered", "accept_rate": 70, "display_name": "Peter Cordes", "link": "http://stackoverflow.com/users/224132/peter-cordes", "profile_image": "https://i.stack.imgur.com/N4ivW.png?s=128&g=1"}, "last_edit_date": 1477724330, "question_id": 38800044}