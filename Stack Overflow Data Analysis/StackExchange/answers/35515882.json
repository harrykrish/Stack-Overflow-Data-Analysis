{"title": "How to spill over quantities to following columns when cumulative sum crosses boundary", "tags": ["sql-server", "tsql", "sql-server-2012"], "creation_date": 1455919282, "score": 2, "body": "<hr>\n\n<h2>Solution for SQL Server 2012+</h2>\n\n<p>As you probably guessed this is done by using Dynamic SQL. Following steps are taken:</p>\n\n<ul>\n<li>Populate a staging table (<code>#staging</code>) with the required columns all having the <code>SUM</code> of all previous rows: <code>SUM(qty) OVER (ORDER BY id ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)</code>. This is done to be able to use <code>LAG</code> in the next step. Reason: you can't have a windowed function over another windowed function.</li>\n<li>Select from the staging table using the <em>overflow</em> mechanism. This uses the <a href=\"https://msdn.microsoft.com/en-us/library/hh231256.aspx\" rel=\"nofollow\"><code>LAG</code></a> function to see if the upper or lower boundary was crossed.</li>\n</ul>\n\n<p>The procedure uses the following constructs: </p>\n\n<ul>\n<li><a href=\"https://msdn.microsoft.com/en-us/library/ms189461.aspx\" rel=\"nofollow\">Windowing functions</a>: <code>SUM() OVER(...)</code>, <code>LAG(...) OVER(...)</code> and <code>ROW_NUMBER() OVER(...)</code>.</li>\n<li>Tally tables for numbering: see this <a href=\"http://stackoverflow.com/q/1393951/243373\">SO thread</a> for more info.</li>\n<li><a href=\"http://stackoverflow.com/q/35148472/243373\"><code>FOR XML PATH('')</code></a> for string concatenation.</li>\n</ul>\n\n<p>PS: I've doubled your sample data to test for three columns.</p>\n\n<hr>\n\n<p>The script:</p>\n\n<pre><code>CREATE TABLE #tt(id INT NOT NULL IDENTITY(1,1) PRIMARY KEY,qty INT NOT NULL);\nINSERT INTO #tt(qty)VALUES\n(240),(101),(43),(43),(24),(43),(59),(11),(65),(200),(16),(1),(195),(50),(40),(240),(101),(43),(43),(24),(43),(59),(11),(65),(200),(16),(1),(195),(50),(40);\n\nDECLARE @tot_cols INT=(CASE WHEN 0=(SELECT SUM(qty) FROM #tt) THEN 1 ELSE (SELECT SUM(qty) FROM #tt) END-1)/1000+1; -- 0 .. 1000 // 1001 .. 2000 // ...\n\nDECLARE @staging_cols NVARCHAR(MAX)=(\n    SELECT N',col'+n+N'=SUM(qty) OVER (ORDER BY id ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)'\n    FROM (\n            SELECT TOP (@tot_cols) CAST(ROW_NUMBER() OVER(ORDER BY t1.number) AS VARCHAR) AS n\n            FROM master.dbo.spt_values AS t1 CROSS JOIN master.dbo.spt_values AS t2\n         ) AS tally\n    WHERE n&lt;=@tot_cols\n    FOR XML PATH('')\n);\nDECLARE @staging_create NVARCHAR(MAX)=\n    N'SELECT id,qty'+@staging_cols+' INTO #staging FROM #tt;';\n\nDECLARE @select_cols NVARCHAR(MAX)=(\n    SELECT N',col'+n+N'='+\n               N'CASE WHEN col'+n+N'&gt;'+b_upper+N' ' +\n                    N'THEN CASE WHEN LAG(col'+n+N') OVER (ORDER BY id)&lt;='+b_upper+N' '+\n                           N'THEN '+b_upper+N'-LAG(col'+n+N') OVER (ORDER BY id) '+\n                           N'ELSE 0 '+\n                           N'END ' +\n                    N'WHEN col'+n+N'&gt;'+b_lower+N' '+\n                    N'THEN CASE WHEN LAG(col'+n+N') OVER (ORDER BY id)&lt;='+b_lower+N' '+ \n                           N'THEN col'+n+N'-'+b_lower+N' '+\n                           N'ELSE qty ' +\n                           N'END ' +\n                    N'ELSE 0 '+\n                N'END'\n    FROM (\n            SELECT TOP (@tot_cols) CAST(ROW_NUMBER() OVER(ORDER BY t1.number) AS VARCHAR) AS n\n            FROM master.dbo.spt_values t1 CROSS JOIN master.dbo.spt_values t2\n         ) AS tally\n         CROSS APPLY (\n            SELECT b_lower=CAST(CASE WHEN n=1 THEN 0 ELSE (n-1)*1000 END AS VARCHAR),\n                   b_upper=CAST(n*1000 AS VARCHAR)\n         ) AS boundaries\n    WHERE n&lt;=@tot_cols\n    FOR XML PATH('')\n);\nDECLARE @select_result NVARCHAR(MAX)=\n    N'SELECT id'+REPLACE(REPLACE(@select_cols,N'&amp;lt;',N'&lt;'),N'&amp;gt;',N'&gt;')+N' FROM #staging ORDER BY id;';\n\nDECLARE @stmt NVARCHAR(MAX)=@staging_create+@select_result+'DROP TABLE #staging;';\nEXEC sp_executesql @stmt;\n\nDROP TABLE #tt;\n</code></pre>\n\n<hr>\n\n<h2>Solution for SQL Server 2008</h2>\n\n<p>This has the same basics (staging table with cumulative sum, lagging to compare to the previous value, tally table...) but uses other constructs.</p>\n\n<p>2008R2 doesn't support <code>SUM()</code> over a window and doesn't support <code>LAG</code>. The cumulative sum is done using a <code>CURSOR</code> (the only reasonable approach in 2008R2-); lagging is done by self-linking the staging table to the previous id. Here goes:</p>\n\n<hr>\n\n<pre><code>CREATE TABLE #tt(id INT NOT NULL IDENTITY(1,1) PRIMARY KEY,qty INT NOT NULL);\nINSERT INTO #tt(qty)VALUES\n(240),(101),(43),(43),(24),(43),(59),(11),(65),(200),(16),(1),(195),(50),(40),(240),(101),(43),(43),(24),(43),(59),(11),(65),(200),(16),(1),(195),(50),(40);\n\nDECLARE @tot_cols INT=(CASE WHEN 0=(SELECT SUM(qty) FROM #tt) THEN 1 ELSE (SELECT SUM(qty) FROM #tt) END-1)/1000+1; -- 0 .. 1000 // 1001 .. 2000 // ...\n\nDECLARE @staging_cols NVARCHAR(MAX)=(\n    SELECT N',col'+n+N'=0'\n    FROM (\n            SELECT TOP (@tot_cols) CAST(ROW_NUMBER() OVER(ORDER BY t1.number) AS VARCHAR) AS n\n            FROM master.dbo.spt_values AS t1 CROSS JOIN master.dbo.spt_values AS t2\n         ) AS tally\n    WHERE n&lt;=@tot_cols\n    FOR XML PATH('')\n);\nDECLARE @staging_create NVARCHAR(MAX)=\n    N'SELECT id,qty'+@staging_cols+' INTO #staging FROM #tt;ALTER TABLE #staging ADD CONSTRAINT PK_staging PRIMARY KEY CLUSTERED (id);';\n\nDECLARE @spillover_cols_sel NVARCHAR(MAX)=STUFF(REPLACE(@staging_cols,N'=0',N''),1,1,N'');\nDECLARE @spillover_cols_upd NVARCHAR(MAX)=STUFF(REPLACE(@staging_cols,N'=0',N'=@tot_qty'),1,1,N'');\nDECLARE @staging_fill NVARCHAR(MAX)=\n    N'DECLARE c_s CURSOR FOR SELECT qty FROM #staging ORDER BY id FOR UPDATE OF '+@spillover_cols_sel+';'+\n    N'OPEN c_s; DECLARE @qty INT; DECLARE @tot_qty INT; SET @tot_qty=0; WHILE 1=1 BEGIN '+\n    N'FETCH NEXT FROM c_s INTO @qty; IF @@FETCH_STATUS&lt;&gt;0 BREAK; SET @tot_qty=@tot_qty+@qty;'+\n    N'UPDATE #staging SET '+@spillover_cols_upd+' WHERE CURRENT OF c_s;'+\n    N'END CLOSE c_s;DEALLOCATE c_s;';\n\nDECLARE @select_cols NVARCHAR(MAX)=(\n    SELECT N',col'+n+N'='+\n               N'CASE WHEN bt.col'+n+N'&gt;'+b_upper+N' ' +\n                    N'THEN CASE WHEN ISNULL(lt.col'+n+N',0)&lt;='+b_upper+N' '+\n                           N'THEN '+b_upper+N'-ISNULL(lt.col'+n+N',0) '+\n                           N'ELSE 0 '+\n                           N'END ' +\n                    N'WHEN bt.col'+n+N'&gt;'+b_lower+N' '+\n                    N'THEN CASE WHEN ISNULL(lt.col'+n+N',0)&lt;='+b_lower+N' '+    \n                           N'THEN bt.col'+n+N'-'+b_lower+N' '+\n                           N'ELSE bt.qty ' +\n                           N'END ' +\n                    N'ELSE 0 '+\n                N'END'\n    FROM (\n            SELECT TOP (@tot_cols) CAST(ROW_NUMBER() OVER(ORDER BY t1.number) AS VARCHAR) AS n\n            FROM master.dbo.spt_values t1 CROSS JOIN master.dbo.spt_values t2\n         ) AS tally\n         CROSS APPLY (\n            SELECT b_lower=CAST(CASE WHEN n=1 THEN 0 ELSE (n-1)*1000 END AS VARCHAR),\n                   b_upper=CAST(n*1000 AS VARCHAR)\n         ) AS boundaries\n    WHERE n&lt;=@tot_cols\n    FOR XML PATH('')\n);\n\nDECLARE @select_result NVARCHAR(MAX)=\n    N'SELECT bt.id'+REPLACE(REPLACE(@select_cols,N'&amp;lt;',N'&lt;'),N'&amp;gt;',N'&gt;')+N' '+\n    N'FROM #staging AS bt LEFT JOIN #staging AS lt ON lt.id=bt.id-1 ORDER BY bt.id;';\n\nDECLARE @stmt NVARCHAR(MAX)=@staging_create+@staging_fill+@select_result+'DROP TABLE #staging;';\nEXEC sp_executesql @stmt;\n\nDROP TABLE #tt;\n</code></pre>\n\n<hr>\n\n<p>Result for both scripts:</p>\n\n<pre><code>+----+------+------+------+\n| id | col1 | col2 | col3 |\n+----+------+------+------+\n|  1 |  240 |    0 |    0 |\n|  2 |  101 |    0 |    0 |\n|  3 |   43 |    0 |    0 |\n|  4 |   43 |    0 |    0 |\n|  5 |   24 |    0 |    0 |\n|  6 |   43 |    0 |    0 |\n|  7 |   59 |    0 |    0 |\n|  8 |   11 |    0 |    0 |\n|  9 |   65 |    0 |    0 |\n| 10 |  200 |    0 |    0 |\n| 11 |   16 |    0 |    0 |\n| 12 |    1 |    0 |    0 |\n| 13 |  154 |   41 |    0 |\n| 14 |    0 |   50 |    0 |\n| 15 |    0 |   40 |    0 |\n| 16 |    0 |  240 |    0 |\n| 17 |    0 |  101 |    0 |\n| 18 |    0 |   43 |    0 |\n| 19 |    0 |   43 |    0 |\n| 20 |    0 |   24 |    0 |\n| 21 |    0 |   43 |    0 |\n| 22 |    0 |   59 |    0 |\n| 23 |    0 |   11 |    0 |\n| 24 |    0 |   65 |    0 |\n| 25 |    0 |  200 |    0 |\n| 26 |    0 |   16 |    0 |\n| 27 |    0 |    1 |    0 |\n| 28 |    0 |   23 |  172 |\n| 29 |    0 |    0 |   50 |\n| 30 |    0 |    0 |   40 |\n+----+------+------+------+\n</code></pre>\n", "last_activity_date": 1477748306, "answer_id": 35515882, "is_accepted": true, "owner": {"user_id": 243373, "reputation": 7351, "user_type": "registered", "display_name": "TT.", "link": "http://stackoverflow.com/users/243373/tt", "profile_image": "https://i.stack.imgur.com/NxxWB.jpg?s=128&g=1"}, "last_edit_date": 1477748306, "question_id": 35448123}