{"title": "WPF ListBox.SelectedItems as ListBoxItem", "tags": ["c#", "wpf", "xaml", "data-binding", "wpf-controls"], "creation_date": 1477596892, "score": 4, "body": "<p>Whatever reason you're doing this for, it's probably a serious violation of MVVM that you'll bitterly regret for the rest of your life. </p>\n\n<p>But the first step on the road to perdition is always an easy one. </p>\n\n<p>Here's how:</p>\n\n<pre><code>var listBox = (ListBox)sender;\nvar selectedListBoxItems = \n    listBox.SelectedItems.Cast&lt;Object&gt;()\n    .Select(item =&gt; (ListBoxItem)listBox.ItemContainerGenerator.ContainerFromItem(item))\n    .ToList();\n</code></pre>\n\n<p>Just don't come crying to me when it all ends in tears. </p>\n\n<p>No but seriously, there's <em>are</em> a few good reasons to do this kind of thing in WPF, but they're far less common than somebody new to WPF would expect. Pretty much any normal case is best handled by having your C# code interacting only with your data items, and do stuff to the ListBoxItems in XAML via styles and templating. Once you get used to that way of thinking, it's very powerful, flexible, productive, and maintainable. Codebehind is what you do for odd cases when all other reasonable avenues fail. Drag and drop, for example. </p>\n", "last_activity_date": 1477668967, "answer_id": 40292867, "is_accepted": true, "owner": {"user_id": 424129, "reputation": 10592, "user_type": "registered", "accept_rate": 79, "display_name": "Ed Plunkett", "link": "http://stackoverflow.com/users/424129/ed-plunkett", "profile_image": "https://i.stack.imgur.com/gkMl8.png?s=128&g=1"}, "last_edit_date": 1477668967, "question_id": 40292787}